# ! [doc = "Peripheral access API for NEORV32 microcontrollers (generated using svd2rust v0.37.0 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next] svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.37.0/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"] # ! [allow (non_camel_case_types)] # ! [allow (non_snake_case)] # ! [no_std] # ! [cfg_attr (docsrs , feature (doc_auto_cfg))]
#[doc = r"Number available in the NVIC for configuring priority"] pub const NVIC_PRIO_BITS : u8 = 4 ;
#[allow (unused_imports)] use generic :: * ;
#[doc = r"Common register and bit access and modify traits"] pub mod generic { use core :: marker ;
#[doc = " Generic peripheral accessor"] pub struct Periph < RB , const A : usize > { _marker : marker :: PhantomData < RB > , } unsafe impl < RB , const A : usize > Send for Periph < RB , A > { } impl < RB , const A : usize > Periph < RB , A > {
#[doc = "Pointer to the register block"] pub const PTR : * const RB = A as * const _ ;
#[doc = "Return the pointer to the register block"]
#[inline (always)] pub const fn ptr () -> * const RB { Self :: PTR }
#[doc = " Steal an instance of this peripheral"]
#[doc = ""]
#[doc = " # Safety"]
#[doc = ""]
#[doc = " Ensure that the new instance of the peripheral cannot be used in a way"]
#[doc = " that may race with any existing instances, for example by only"]
#[doc = " accessing read-only or write-only registers, or by consuming the"]
#[doc = " original peripheral and using critical sections to coordinate"]
#[doc = " access between multiple new instances."]
#[doc = ""]
#[doc = " Additionally, other software such as HALs may rely on only one"]
#[doc = " peripheral instance existing to ensure memory safety; ensure"]
#[doc = " no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : marker :: PhantomData , } } } impl < RB , const A : usize > core :: ops :: Deref for Periph < RB , A > { type Target = RB ;
#[inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } }
#[doc = " Raw register type (`u8`, `u16`, `u32`, ...)"] pub trait RawReg : Copy + From < bool > + core :: ops :: BitOr < Output = Self > + core :: ops :: BitAnd < Output = Self > + core :: ops :: BitOrAssign + core :: ops :: BitAndAssign + core :: ops :: Not < Output = Self > + core :: ops :: Shl < u8 , Output = Self > {
#[doc = " Mask for bits of width `WI`"] fn mask < const WI : u8 > () -> Self ;
#[doc = " `0`"] const ZERO : Self ;
#[doc = " `1`"] const ONE : Self ; } macro_rules ! raw_reg { ($ U : ty , $ size : literal , $ mask : ident) => { impl RawReg for $ U {
#[inline (always)] fn mask < const WI : u8 > () -> Self { $ mask ::< WI > () } const ZERO : Self = 0 ; const ONE : Self = 1 ; } const fn $ mask < const WI : u8 > () -> $ U { <$ U >:: MAX >> ($ size - WI) } impl FieldSpec for $ U { type Ux = $ U ; } } ; } raw_reg ! (u8 , 8 , mask_u8) ; raw_reg ! (u16 , 16 , mask_u16) ; raw_reg ! (u32 , 32 , mask_u32) ; raw_reg ! (u64 , 64 , mask_u64) ;
#[doc = " Raw register type"] pub trait RegisterSpec {
#[doc = " Raw register type (`u8`, `u16`, `u32`, ...)."] type Ux : RawReg ; }
#[doc = " Raw field type"] pub trait FieldSpec : Sized {
#[doc = " Raw field type (`u8`, `u16`, `u32`, ...)."] type Ux : Copy + core :: fmt :: Debug + PartialEq + From < Self > ; }
#[doc = " Marker for fields with fixed values"] pub trait IsEnum : FieldSpec { }
#[doc = " Trait implemented by readable registers to enable the `read` method."]
#[doc = ""]
#[doc = " Registers marked with `Writable` can be also be `modify`'ed."] pub trait Readable : RegisterSpec { }
#[doc = " Trait implemented by writeable registers."]
#[doc = ""]
#[doc = " This enables the  `write`, `write_with_zero` and `reset` methods."]
#[doc = ""]
#[doc = " Registers marked with `Readable` can be also be `modify`'ed."] pub trait Writable : RegisterSpec {
#[doc = " Is it safe to write any bits to register"] type Safety ;
#[doc = " Specifies the register bits that are not changed if you pass `1` and are changed if you pass `0`"] const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = Self :: Ux :: ZERO ;
#[doc = " Specifies the register bits that are not changed if you pass `0` and are changed if you pass `1`"] const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = Self :: Ux :: ZERO ; }
#[doc = " Reset value of the register."]
#[doc = ""]
#[doc = " This value is the initial value for the `write` method. It can also be directly written to the"]
#[doc = " register by using the `reset` method."] pub trait Resettable : RegisterSpec {
#[doc = " Reset value of the register."] const RESET_VALUE : Self :: Ux = Self :: Ux :: ZERO ;
#[doc = " Reset value of the register."]
#[inline (always)] fn reset_value () -> Self :: Ux { Self :: RESET_VALUE } }
#[doc (hidden)] pub mod raw { use super :: { marker , BitM , FieldSpec , RegisterSpec , Unsafe , Writable } ; pub struct R < REG : RegisterSpec > { pub (crate) bits : REG :: Ux , pub (super) _reg : marker :: PhantomData < REG > , } pub struct W < REG : RegisterSpec > {
#[doc = "Writable bits"] pub (crate) bits : REG :: Ux , pub (super) _reg : marker :: PhantomData < REG > , } pub struct FieldReader < FI = u8 > where FI : FieldSpec , { pub (crate) bits : FI :: Ux , _reg : marker :: PhantomData < FI > , } impl < FI : FieldSpec > FieldReader < FI > {
#[doc = " Creates a new instance of the reader."]
#[allow (unused)]
#[inline (always)] pub (crate) const fn new (bits : FI :: Ux) -> Self { Self { bits , _reg : marker :: PhantomData , } } } pub struct BitReader < FI = bool > { pub (crate) bits : bool , _reg : marker :: PhantomData < FI > , } impl < FI > BitReader < FI > {
#[doc = " Creates a new instance of the reader."]
#[allow (unused)]
#[inline (always)] pub (crate) const fn new (bits : bool) -> Self { Self { bits , _reg : marker :: PhantomData , } } }
#[must_use = "after creating `FieldWriter` you need to call field value setting method"] pub struct FieldWriter < 'a , REG , const WI : u8 , FI = u8 , Safety = Unsafe > where REG : Writable + RegisterSpec , FI : FieldSpec , { pub (crate) w : & 'a mut W < REG > , pub (crate) o : u8 , _field : marker :: PhantomData < (FI , Safety) > , } impl < 'a , REG , const WI : u8 , FI , Safety > FieldWriter < 'a , REG , WI , FI , Safety > where REG : Writable + RegisterSpec , FI : FieldSpec , {
#[doc = " Creates a new instance of the writer"]
#[allow (unused)]
#[inline (always)] pub (crate) fn new (w : & 'a mut W < REG > , o : u8) -> Self { Self { w , o , _field : marker :: PhantomData , } } }
#[must_use = "after creating `BitWriter` you need to call bit setting method"] pub struct BitWriter < 'a , REG , FI = bool , M = BitM > where REG : Writable + RegisterSpec , bool : From < FI > , { pub (crate) w : & 'a mut W < REG > , pub (crate) o : u8 , _field : marker :: PhantomData < (FI , M) > , } impl < 'a , REG , FI , M > BitWriter < 'a , REG , FI , M > where REG : Writable + RegisterSpec , bool : From < FI > , {
#[doc = " Creates a new instance of the writer"]
#[allow (unused)]
#[inline (always)] pub (crate) fn new (w : & 'a mut W < REG > , o : u8) -> Self { Self { w , o , _field : marker :: PhantomData , } } } }
#[doc = " Register reader."]
#[doc = ""]
#[doc = " Result of the `read` methods of registers. Also used as a closure argument in the `modify`"]
#[doc = " method."] pub type R < REG > = raw :: R < REG > ; impl < REG : RegisterSpec > R < REG > {
#[doc = " Reads raw bits from register."]
#[inline (always)] pub const fn bits (& self) -> REG :: Ux { self . bits } } impl < REG : RegisterSpec , FI > PartialEq < FI > for R < REG > where REG :: Ux : PartialEq , FI : Copy , REG :: Ux : From < FI > , {
#[inline (always)] fn eq (& self , other : & FI) -> bool { self . bits . eq (& REG :: Ux :: from (* other)) } }
#[doc = " Register writer."]
#[doc = ""]
#[doc = " Used as an argument to the closures in the `write` and `modify` methods of the register."] pub type W < REG > = raw :: W < REG > ; impl < REG : Writable > W < REG > {
#[doc = " Writes raw bits to the register."]
#[doc = ""]
#[doc = " # Safety"]
#[doc = ""]
#[doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
#[inline (always)] pub unsafe fn bits (& mut self , bits : REG :: Ux) -> & mut Self { self . bits = bits ; self } } impl < REG > W < REG > where REG : Writable < Safety = Safe > , {
#[doc = " Writes raw bits to the register."]
#[inline (always)] pub fn set (& mut self , bits : REG :: Ux) -> & mut Self { self . bits = bits ; self } }
#[doc = " Field reader."]
#[doc = ""]
#[doc = " Result of the `read` methods of fields."] pub type FieldReader < FI = u8 > = raw :: FieldReader < FI > ;
#[doc = " Bit-wise field reader"] pub type BitReader < FI = bool > = raw :: BitReader < FI > ; impl < FI : FieldSpec > FieldReader < FI > {
#[doc = " Reads raw bits from field."]
#[inline (always)] pub const fn bits (& self) -> FI :: Ux { self . bits } } impl < FI : FieldSpec > core :: fmt :: Debug for FieldReader < FI > { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { core :: fmt :: Debug :: fmt (& self . bits , f) } } impl < FI > PartialEq < FI > for FieldReader < FI > where FI : FieldSpec + Copy , {
#[inline (always)] fn eq (& self , other : & FI) -> bool { self . bits . eq (& FI :: Ux :: from (* other)) } } impl < FI > PartialEq < FI > for BitReader < FI > where FI : Copy , bool : From < FI > , {
#[inline (always)] fn eq (& self , other : & FI) -> bool { self . bits . eq (& bool :: from (* other)) } } impl < FI > BitReader < FI > {
#[doc = " Value of the field as raw bits."]
#[inline (always)] pub const fn bit (& self) -> bool { self . bits }
#[doc = " Returns `true` if the bit is clear (0)."]
#[inline (always)] pub const fn bit_is_clear (& self) -> bool { ! self . bit () }
#[doc = " Returns `true` if the bit is set (1)."]
#[inline (always)] pub const fn bit_is_set (& self) -> bool { self . bit () } } impl < FI > core :: fmt :: Debug for BitReader < FI > { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { core :: fmt :: Debug :: fmt (& self . bits , f) } }
#[doc = " Marker for register/field writers which can take any value of specified width"] pub struct Safe ;
#[doc = " You should check that value is allowed to pass to register/field writer marked with this"] pub struct Unsafe ;
#[doc = " Marker for field writers are safe to write in specified inclusive range"] pub struct Range < const MIN : u64 , const MAX : u64 > ;
#[doc = " Marker for field writers are safe to write in specified inclusive range"] pub struct RangeFrom < const MIN : u64 > ;
#[doc = " Marker for field writers are safe to write in specified inclusive range"] pub struct RangeTo < const MAX : u64 > ;
#[doc = " Write field Proxy"] pub type FieldWriter < 'a , REG , const WI : u8 , FI = u8 , Safety = Unsafe > = raw :: FieldWriter < 'a , REG , WI , FI , Safety > ; impl < REG , const WI : u8 , FI , Safety > FieldWriter < '_ , REG , WI , FI , Safety > where REG : Writable + RegisterSpec , FI : FieldSpec , {
#[doc = " Field width"] pub const WIDTH : u8 = WI ;
#[doc = " Field width"]
#[inline (always)] pub const fn width (& self) -> u8 { WI }
#[doc = " Field offset"]
#[inline (always)] pub const fn offset (& self) -> u8 { self . o } } impl < 'a , REG , const WI : u8 , FI , Safety > FieldWriter < 'a , REG , WI , FI , Safety > where REG : Writable + RegisterSpec , FI : FieldSpec , REG :: Ux : From < FI :: Ux > , {
#[doc = " Writes raw bits to the field"]
#[doc = ""]
#[doc = " # Safety"]
#[doc = ""]
#[doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
#[inline (always)] pub unsafe fn bits (self , value : FI :: Ux) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: mask :: < WI > () << self . o) ; self . w . bits |= (REG :: Ux :: from (value) & REG :: Ux :: mask :: < WI > ()) << self . o ; self . w } } impl < 'a , REG , const WI : u8 , FI > FieldWriter < 'a , REG , WI , FI , Safe > where REG : Writable + RegisterSpec , FI : FieldSpec , REG :: Ux : From < FI :: Ux > , {
#[doc = " Writes raw bits to the field"]
#[inline (always)] pub fn set (self , value : FI :: Ux) -> & 'a mut W < REG > { unsafe { self . bits (value) } } } impl < 'a , REG , const WI : u8 , FI , const MIN : u64 , const MAX : u64 > FieldWriter < 'a , REG , WI , FI , Range < MIN , MAX > > where REG : Writable + RegisterSpec , FI : FieldSpec , REG :: Ux : From < FI :: Ux > , u64 : From < FI :: Ux > , {
#[doc = " Writes raw bits to the field"]
#[inline (always)] pub fn set (self , value : FI :: Ux) -> & 'a mut W < REG > { { let value = u64 :: from (value) ; assert ! (value >= MIN && value <= MAX) ; } unsafe { self . bits (value) } } } impl < 'a , REG , const WI : u8 , FI , const MIN : u64 > FieldWriter < 'a , REG , WI , FI , RangeFrom < MIN > > where REG : Writable + RegisterSpec , FI : FieldSpec , REG :: Ux : From < FI :: Ux > , u64 : From < FI :: Ux > , {
#[doc = " Writes raw bits to the field"]
#[inline (always)] pub fn set (self , value : FI :: Ux) -> & 'a mut W < REG > { { let value = u64 :: from (value) ; assert ! (value >= MIN) ; } unsafe { self . bits (value) } } } impl < 'a , REG , const WI : u8 , FI , const MAX : u64 > FieldWriter < 'a , REG , WI , FI , RangeTo < MAX > > where REG : Writable + RegisterSpec , FI : FieldSpec , REG :: Ux : From < FI :: Ux > , u64 : From < FI :: Ux > , {
#[doc = " Writes raw bits to the field"]
#[inline (always)] pub fn set (self , value : FI :: Ux) -> & 'a mut W < REG > { { let value = u64 :: from (value) ; assert ! (value <= MAX) ; } unsafe { self . bits (value) } } } impl < 'a , REG , const WI : u8 , FI , Safety > FieldWriter < 'a , REG , WI , FI , Safety > where REG : Writable + RegisterSpec , FI : IsEnum , REG :: Ux : From < FI :: Ux > , {
#[doc = " Writes `variant` to the field"]
#[inline (always)] pub fn variant (self , variant : FI) -> & 'a mut W < REG > { unsafe { self . bits (FI :: Ux :: from (variant)) } } } macro_rules ! bit_proxy { ($ writer : ident , $ mwv : ident) => {
#[doc (hidden)] pub struct $ mwv ;
#[doc = " Bit-wise write field proxy"] pub type $ writer <'a , REG , FI = bool > = raw :: BitWriter <'a , REG , FI , $ mwv >; impl <'a , REG , FI > $ writer <'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI >, {
#[doc = " Field width"] pub const WIDTH : u8 = 1 ;
#[doc = " Field width"]
#[inline (always)] pub const fn width (& self) -> u8 { Self :: WIDTH }
#[doc = " Field offset"]
#[inline (always)] pub const fn offset (& self) -> u8 { self . o }
#[doc = " Writes bit to the field"]
#[inline (always)] pub fn bit (self , value : bool) -> &'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: ONE << self . o) ; self . w . bits |= (REG :: Ux :: from (value) & REG :: Ux :: ONE) << self . o ; self . w }
#[doc = " Writes `variant` to the field"]
#[inline (always)] pub fn variant (self , variant : FI) -> &'a mut W < REG > { self . bit (bool :: from (variant)) } } } ; } bit_proxy ! (BitWriter , BitM) ; bit_proxy ! (BitWriter1S , Bit1S) ; bit_proxy ! (BitWriter0C , Bit0C) ; bit_proxy ! (BitWriter1C , Bit1C) ; bit_proxy ! (BitWriter0S , Bit0S) ; bit_proxy ! (BitWriter1T , Bit1T) ; bit_proxy ! (BitWriter0T , Bit0T) ; impl < 'a , REG , FI > BitWriter < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , {
#[doc = " Sets the field bit"]
#[inline (always)] pub fn set_bit (self) -> & 'a mut W < REG > { self . w . bits |= REG :: Ux :: ONE << self . o ; self . w }
#[doc = " Clears the field bit"]
#[inline (always)] pub fn clear_bit (self) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: ONE << self . o) ; self . w } } impl < 'a , REG , FI > BitWriter1S < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , {
#[doc = " Sets the field bit"]
#[inline (always)] pub fn set_bit (self) -> & 'a mut W < REG > { self . w . bits |= REG :: Ux :: ONE << self . o ; self . w } } impl < 'a , REG , FI > BitWriter0C < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , {
#[doc = " Clears the field bit"]
#[inline (always)] pub fn clear_bit (self) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: ONE << self . o) ; self . w } } impl < 'a , REG , FI > BitWriter1C < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , {
#[doc = "Clears the field bit by passing one"]
#[inline (always)] pub fn clear_bit_by_one (self) -> & 'a mut W < REG > { self . w . bits |= REG :: Ux :: ONE << self . o ; self . w } } impl < 'a , REG , FI > BitWriter0S < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , {
#[doc = "Sets the field bit by passing zero"]
#[inline (always)] pub fn set_bit_by_zero (self) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: ONE << self . o) ; self . w } } impl < 'a , REG , FI > BitWriter1T < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , {
#[doc = "Toggle the field bit by passing one"]
#[inline (always)] pub fn toggle_bit (self) -> & 'a mut W < REG > { self . w . bits |= REG :: Ux :: ONE << self . o ; self . w } } impl < 'a , REG , FI > BitWriter0T < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , {
#[doc = "Toggle the field bit by passing zero"]
#[inline (always)] pub fn toggle_bit (self) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: ONE << self . o) ; self . w } }
#[doc = " This structure provides volatile access to registers."]
#[repr (transparent)] pub struct Reg < REG : RegisterSpec > { register : vcell :: VolatileCell < REG :: Ux > , _marker : marker :: PhantomData < REG > , } unsafe impl < REG : RegisterSpec > Send for Reg < REG > where REG :: Ux : Send { } impl < REG : RegisterSpec > Reg < REG > {
#[doc = " Returns the underlying memory address of register."]
#[doc = ""]
#[doc = " ```ignore"]
#[doc = " let reg_ptr = periph.reg.as_ptr();"]
#[doc = " ```"]
#[inline (always)] pub fn as_ptr (& self) -> * mut REG :: Ux { self . register . as_ptr () } } impl < REG : Readable > Reg < REG > {
#[doc = " Reads the contents of a `Readable` register."]
#[doc = ""]
#[doc = " You can read the raw contents of a register by using `bits`:"]
#[doc = " ```ignore"]
#[doc = " let bits = periph.reg.read().bits();"]
#[doc = " ```"]
#[doc = " or get the content of a particular field of a register:"]
#[doc = " ```ignore"]
#[doc = " let reader = periph.reg.read();"]
#[doc = " let bits = reader.field1().bits();"]
#[doc = " let flag = reader.field2().bit_is_set();"]
#[doc = " ```"]
#[inline (always)] pub fn read (& self) -> R < REG > { R { bits : self . register . get () , _reg : marker :: PhantomData , } } } impl < REG : Resettable + Writable > Reg < REG > {
#[doc = " Writes the reset value to `Writable` register."]
#[doc = ""]
#[doc = " Resets the register to its initial state."]
#[inline (always)] pub fn reset (& self) { self . register . set (REG :: RESET_VALUE) }
#[doc = " Writes bits to a `Writable` register."]
#[doc = ""]
#[doc = " You can write raw bits into a register:"]
#[doc = " ```ignore"]
#[doc = " periph.reg.write(|w| unsafe { w.bits(rawbits) });"]
#[doc = " ```"]
#[doc = " or write only the fields you need:"]
#[doc = " ```ignore"]
#[doc = " periph.reg.write(|w| w"]
#[doc = "     .field1().bits(newfield1bits)"]
#[doc = "     .field2().set_bit()"]
#[doc = "     .field3().variant(VARIANT)"]
#[doc = " );"]
#[doc = " ```"]
#[doc = " or an alternative way of saying the same:"]
#[doc = " ```ignore"]
#[doc = " periph.reg.write(|w| {"]
#[doc = "     w.field1().bits(newfield1bits);"]
#[doc = "     w.field2().set_bit();"]
#[doc = "     w.field3().variant(VARIANT)"]
#[doc = " });"]
#[doc = " ```"]
#[doc = " In the latter case, other fields will be set to their reset value."]
#[inline (always)] pub fn write < F > (& self , f : F) -> REG :: Ux where F : FnOnce (& mut W < REG >) -> & mut W < REG > , { let value = f (& mut W { bits : REG :: RESET_VALUE & ! REG :: ONE_TO_MODIFY_FIELDS_BITMAP | REG :: ZERO_TO_MODIFY_FIELDS_BITMAP , _reg : marker :: PhantomData , }) . bits ; self . register . set (value) ; value }
#[doc = " Writes bits to a `Writable` register and produce a value."]
#[doc = ""]
#[doc = " You can write raw bits into a register:"]
#[doc = " ```ignore"]
#[doc = " periph.reg.write_and(|w| unsafe { w.bits(rawbits); });"]
#[doc = " ```"]
#[doc = " or write only the fields you need:"]
#[doc = " ```ignore"]
#[doc = " periph.reg.write_and(|w| {"]
#[doc = "     w.field1().bits(newfield1bits)"]
#[doc = "         .field2().set_bit()"]
#[doc = "         .field3().variant(VARIANT);"]
#[doc = " });"]
#[doc = " ```"]
#[doc = " or an alternative way of saying the same:"]
#[doc = " ```ignore"]
#[doc = " periph.reg.write_and(|w| {"]
#[doc = "     w.field1().bits(newfield1bits);"]
#[doc = "     w.field2().set_bit();"]
#[doc = "     w.field3().variant(VARIANT);"]
#[doc = " });"]
#[doc = " ```"]
#[doc = " In the latter case, other fields will be set to their reset value."]
#[doc = ""]
#[doc = " Values can be returned from the closure:"]
#[doc = " ```ignore"]
#[doc = " let state = periph.reg.write_and(|w| State::set(w.field1()));"]
#[doc = " ```"]
#[inline (always)] pub fn from_write < F , T > (& self , f : F) -> T where F : FnOnce (& mut W < REG >) -> T , { let mut writer = W { bits : REG :: RESET_VALUE & ! REG :: ONE_TO_MODIFY_FIELDS_BITMAP | REG :: ZERO_TO_MODIFY_FIELDS_BITMAP , _reg : marker :: PhantomData , } ; let result = f (& mut writer) ; self . register . set (writer . bits) ; result } } impl < REG : Writable > Reg < REG > {
#[doc = " Writes 0 to a `Writable` register."]
#[doc = ""]
#[doc = " Similar to `write`, but unused bits will contain 0."]
#[doc = ""]
#[doc = " # Safety"]
#[doc = ""]
#[doc = " Unsafe to use with registers which don't allow to write 0."]
#[inline (always)] pub unsafe fn write_with_zero < F > (& self , f : F) -> REG :: Ux where F : FnOnce (& mut W < REG >) -> & mut W < REG > , { let value = f (& mut W { bits : REG :: Ux :: ZERO , _reg : marker :: PhantomData , }) . bits ; self . register . set (value) ; value }
#[doc = " Writes 0 to a `Writable` register and produces a value."]
#[doc = ""]
#[doc = " Similar to `write`, but unused bits will contain 0."]
#[doc = ""]
#[doc = " # Safety"]
#[doc = ""]
#[doc = " Unsafe to use with registers which don't allow to write 0."]
#[inline (always)] pub unsafe fn from_write_with_zero < F , T > (& self , f : F) -> T where F : FnOnce (& mut W < REG >) -> T , { let mut writer = W { bits : REG :: Ux :: ZERO , _reg : marker :: PhantomData , } ; let result = f (& mut writer) ; self . register . set (writer . bits) ; result } } impl < REG : Readable + Writable > Reg < REG > {
#[doc = " Modifies the contents of the register by reading and then writing it."]
#[doc = ""]
#[doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
#[doc = " ```ignore"]
#[doc = " periph.reg.modify(|r, w| unsafe { w.bits("]
#[doc = "    r.bits() | 3"]
#[doc = " ) });"]
#[doc = " ```"]
#[doc = " or"]
#[doc = " ```ignore"]
#[doc = " periph.reg.modify(|_, w| w"]
#[doc = "     .field1().bits(newfield1bits)"]
#[doc = "     .field2().set_bit()"]
#[doc = "     .field3().variant(VARIANT)"]
#[doc = " );"]
#[doc = " ```"]
#[doc = " or an alternative way of saying the same:"]
#[doc = " ```ignore"]
#[doc = " periph.reg.modify(|_, w| {"]
#[doc = "     w.field1().bits(newfield1bits);"]
#[doc = "     w.field2().set_bit();"]
#[doc = "     w.field3().variant(VARIANT)"]
#[doc = " });"]
#[doc = " ```"]
#[doc = " Other fields will have the value they had before the call to `modify`."]
#[inline (always)] pub fn modify < F > (& self , f : F) -> REG :: Ux where for < 'w > F : FnOnce (& R < REG > , & 'w mut W < REG >) -> & 'w mut W < REG > , { let bits = self . register . get () ; let value = f (& R { bits , _reg : marker :: PhantomData , } , & mut W { bits : bits & ! REG :: ONE_TO_MODIFY_FIELDS_BITMAP | REG :: ZERO_TO_MODIFY_FIELDS_BITMAP , _reg : marker :: PhantomData , } ,) . bits ; self . register . set (value) ; value }
#[doc = " Modifies the contents of the register by reading and then writing it"]
#[doc = " and produces a value."]
#[doc = ""]
#[doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
#[doc = " ```ignore"]
#[doc = " let bits = periph.reg.modify(|r, w| {"]
#[doc = "     let new_bits = r.bits() | 3;"]
#[doc = "     unsafe {"]
#[doc = "         w.bits(new_bits);"]
#[doc = "     }"]
#[doc = ""]
#[doc = "     new_bits"]
#[doc = " });"]
#[doc = " ```"]
#[doc = " or"]
#[doc = " ```ignore"]
#[doc = " periph.reg.modify(|_, w| {"]
#[doc = "     w.field1().bits(newfield1bits)"]
#[doc = "         .field2().set_bit()"]
#[doc = "         .field3().variant(VARIANT);"]
#[doc = " });"]
#[doc = " ```"]
#[doc = " or an alternative way of saying the same:"]
#[doc = " ```ignore"]
#[doc = " periph.reg.modify(|_, w| {"]
#[doc = "     w.field1().bits(newfield1bits);"]
#[doc = "     w.field2().set_bit();"]
#[doc = "     w.field3().variant(VARIANT);"]
#[doc = " });"]
#[doc = " ```"]
#[doc = " Other fields will have the value they had before the call to `modify`."]
#[inline (always)] pub fn from_modify < F , T > (& self , f : F) -> T where for < 'w > F : FnOnce (& R < REG > , & 'w mut W < REG >) -> T , { let bits = self . register . get () ; let mut writer = W { bits : bits & ! REG :: ONE_TO_MODIFY_FIELDS_BITMAP | REG :: ZERO_TO_MODIFY_FIELDS_BITMAP , _reg : marker :: PhantomData , } ; let result = f (& R { bits , _reg : marker :: PhantomData , } , & mut writer ,) ; self . register . set (writer . bits) ; result } } impl < REG : Readable > core :: fmt :: Debug for crate :: generic :: Reg < REG > where R < REG > : core :: fmt :: Debug , { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { core :: fmt :: Debug :: fmt (& self . read () , f) } } }
#[cfg (feature = "rt")] unsafe extern "C" { fn TWD_FIRQ () ; fn CFS_FIRQ () ; fn UART0_FIRQ () ; fn UART1_FIRQ () ; fn TRACER_FIRQ () ; fn SPI_FIRQ () ; fn TWI_FIRQ () ; fn GPIO_FIRQ () ; fn NEOLED_FIRQ () ; fn DMA_FIRQ () ; fn SDI_FIRQ () ; fn GPTMR_FIRQ () ; fn ONEWIRE_FIRQ () ; fn SLINK_FIRQ () ; fn TRNG_FIRQ () ; }
#[doc (hidden)]
#[repr (C)] pub union Vector { pub _handler : unsafe extern "C" fn () , pub _reserved : usize , }
#[cfg (feature = "rt")]
#[doc (hidden)]
#[unsafe (no_mangle)] pub static __EXTERNAL_INTERRUPTS : [Vector ; 16] = [Vector { _handler : TWD_FIRQ } , Vector { _handler : CFS_FIRQ } , Vector { _handler : UART0_FIRQ } , Vector { _handler : UART1_FIRQ } , Vector { _reserved : 0 } , Vector { _handler : TRACER_FIRQ } , Vector { _handler : SPI_FIRQ } , Vector { _handler : TWI_FIRQ } , Vector { _handler : GPIO_FIRQ } , Vector { _handler : NEOLED_FIRQ } , Vector { _handler : DMA_FIRQ } , Vector { _handler : SDI_FIRQ } , Vector { _handler : GPTMR_FIRQ } , Vector { _handler : ONEWIRE_FIRQ } , Vector { _handler : SLINK_FIRQ } , Vector { _handler : TRNG_FIRQ } ,] ;
#[doc (hidden)] pub mod interrupt {
#[doc = r"Enumeration of all the interrupts."]
#[derive (Copy , Clone , Debug , PartialEq , Eq)]
#[repr (u16)] pub enum Interrupt {
#[doc = "0 - TWD_FIRQ"] TWD_FIRQ = 0 ,
#[doc = "1 - CFS_FIRQ"] CFS_FIRQ = 1 ,
#[doc = "2 - UART0_FIRQ"] UART0_FIRQ = 2 ,
#[doc = "3 - UART1_FIRQ"] UART1_FIRQ = 3 ,
#[doc = "5 - TRACER_FIRQ"] TRACER_FIRQ = 5 ,
#[doc = "6 - SPI_FIRQ"] SPI_FIRQ = 6 ,
#[doc = "7 - TWI_FIRQ"] TWI_FIRQ = 7 ,
#[doc = "8 - GPIO_FIRQ"] GPIO_FIRQ = 8 ,
#[doc = "9 - NEOLED_FIRQ"] NEOLED_FIRQ = 9 ,
#[doc = "10 - DMA_FIRQ"] DMA_FIRQ = 10 ,
#[doc = "11 - SDI_FIRQ"] SDI_FIRQ = 11 ,
#[doc = "12 - GPTMR_FIRQ"] GPTMR_FIRQ = 12 ,
#[doc = "13 - ONEWIRE_FIRQ"] ONEWIRE_FIRQ = 13 ,
#[doc = "14 - SLINK_FIRQ"] SLINK_FIRQ = 14 ,
#[doc = "15 - TRNG_FIRQ"] TRNG_FIRQ = 15 , }
#[doc = r" TryFromInterruptError"]
#[derive (Debug , Copy , Clone)] pub struct TryFromInterruptError (()) ; impl Interrupt {
#[doc = r" Attempt to convert a given value into an `Interrupt`"]
#[inline] pub fn try_from (value : u8) -> Result < Self , TryFromInterruptError > { match value { 0 => Ok (Interrupt :: TWD_FIRQ) , 1 => Ok (Interrupt :: CFS_FIRQ) , 2 => Ok (Interrupt :: UART0_FIRQ) , 3 => Ok (Interrupt :: UART1_FIRQ) , 5 => Ok (Interrupt :: TRACER_FIRQ) , 6 => Ok (Interrupt :: SPI_FIRQ) , 7 => Ok (Interrupt :: TWI_FIRQ) , 8 => Ok (Interrupt :: GPIO_FIRQ) , 9 => Ok (Interrupt :: NEOLED_FIRQ) , 10 => Ok (Interrupt :: DMA_FIRQ) , 11 => Ok (Interrupt :: SDI_FIRQ) , 12 => Ok (Interrupt :: GPTMR_FIRQ) , 13 => Ok (Interrupt :: ONEWIRE_FIRQ) , 14 => Ok (Interrupt :: SLINK_FIRQ) , 15 => Ok (Interrupt :: TRNG_FIRQ) , _ => Err (TryFromInterruptError (())) , } } }
#[cfg (feature = "rt")]
#[macro_export]
#[doc = r" Assigns a handler to an interrupt"]
#[doc = r""]
#[doc = r" This macro takes two arguments: the name of an interrupt and the path to the"]
#[doc = r" function that will be used as the handler of that interrupt. That function"]
#[doc = r" must have signature `fn()`."]
#[doc = r""]
#[doc = r" Optionally, a third argument may be used to declare interrupt local data."]
#[doc = r" The handler will have exclusive access to these *local* variables on each"]
#[doc = r" invocation. If the third argument is used then the signature of the handler"]
#[doc = r" function must be `fn(&mut $NAME::Locals)` where `$NAME` is the first argument"]
#[doc = r" passed to the macro."]
#[doc = r""]
#[doc = r" # Example"]
#[doc = r""]
#[doc = r" ``` ignore"]
#[doc = r" interrupt!(TIM2, periodic);"]
#[doc = r""]
#[doc = r" fn periodic() {"]
#[doc = r#"     print!(".");"#]
#[doc = r" }"]
#[doc = r""]
#[doc = r" interrupt!(TIM3, tick, locals: {"]
#[doc = r"     tick: bool = false;"]
#[doc = r" });"]
#[doc = r""]
#[doc = r" fn tick(locals: &mut TIM3::Locals) {"]
#[doc = r"     locals.tick = !locals.tick;"]
#[doc = r""]
#[doc = r"     if locals.tick {"]
#[doc = r#"         println!("Tick");"#]
#[doc = r"     } else {"]
#[doc = r#"         println!("Tock");"#]
#[doc = r"     }"]
#[doc = r" }"]
#[doc = r" ```"] macro_rules ! interrupt { ($ NAME : ident , $ path : path , locals : { $ ($ lvar : ident : $ lty : ty = $ lval : expr ;) * }) => {
#[allow (non_snake_case)] mod $ NAME { pub struct Locals { $ (pub $ lvar : $ lty ,) * } }
#[allow (non_snake_case)]
#[unsafe (no_mangle)] pub extern "C" fn $ NAME () { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; static mut LOCALS : self :: $ NAME :: Locals = self :: $ NAME :: Locals { $ ($ lvar : $ lval ,) * } ; let f : fn (& mut self :: $ NAME :: Locals) = $ path ; f (unsafe { & mut LOCALS }) ; } } ; ($ NAME : ident , $ path : path) => {
#[allow (non_snake_case)]
#[unsafe (no_mangle)] pub extern "C" fn $ NAME () { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; let f : fn () = $ path ; f () ; } } } } pub use self :: interrupt :: Interrupt ;
#[doc = "Custom functions subsystem"] pub type Cfs = crate :: Periph < cfs :: RegisterBlock , 0xffeb_0000 > ; impl core :: fmt :: Debug for Cfs { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cfs") . finish () } }
#[doc = "Custom functions subsystem"] pub mod cfs {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { reg0 : Reg0 , reg1 : Reg1 , reg2 : Reg2 , reg3 : Reg3 , reg4 : Reg4 , reg5 : Reg5 , reg6 : Reg6 , reg7 : Reg7 , reg8 : Reg8 , reg9 : Reg9 , reg10 : Reg10 , reg11 : Reg11 , reg12 : Reg12 , reg13 : Reg13 , reg14 : Reg14 , reg15 : Reg15 , reg16 : Reg16 , reg17 : Reg17 , reg18 : Reg18 , reg19 : Reg19 , reg20 : Reg20 , reg21 : Reg21 , reg22 : Reg22 , reg23 : Reg23 , reg24 : Reg24 , reg25 : Reg25 , reg26 : Reg26 , reg27 : Reg27 , reg28 : Reg28 , reg29 : Reg29 , reg30 : Reg30 , reg31 : Reg31 , reg32 : Reg32 , reg33 : Reg33 , reg34 : Reg34 , reg35 : Reg35 , reg36 : Reg36 , reg37 : Reg37 , reg38 : Reg38 , reg39 : Reg39 , reg40 : Reg40 , reg41 : Reg41 , reg42 : Reg42 , reg43 : Reg43 , reg44 : Reg44 , reg45 : Reg45 , reg46 : Reg46 , reg47 : Reg47 , reg48 : Reg48 , reg49 : Reg49 , reg50 : Reg50 , reg51 : Reg51 , reg52 : Reg52 , reg53 : Reg53 , reg54 : Reg54 , reg55 : Reg55 , reg56 : Reg56 , reg57 : Reg57 , reg58 : Reg58 , reg59 : Reg59 , reg60 : Reg60 , reg61 : Reg61 , reg62 : Reg62 , reg63 : Reg63 , } impl RegisterBlock {
#[doc = "0x00 - User-defined"]
#[inline (always)] pub const fn reg0 (& self) -> & Reg0 { & self . reg0 }
#[doc = "0x04 - User-defined"]
#[inline (always)] pub const fn reg1 (& self) -> & Reg1 { & self . reg1 }
#[doc = "0x08 - User-defined"]
#[inline (always)] pub const fn reg2 (& self) -> & Reg2 { & self . reg2 }
#[doc = "0x0c - User-defined"]
#[inline (always)] pub const fn reg3 (& self) -> & Reg3 { & self . reg3 }
#[doc = "0x10 - User-defined"]
#[inline (always)] pub const fn reg4 (& self) -> & Reg4 { & self . reg4 }
#[doc = "0x14 - User-defined"]
#[inline (always)] pub const fn reg5 (& self) -> & Reg5 { & self . reg5 }
#[doc = "0x18 - User-defined"]
#[inline (always)] pub const fn reg6 (& self) -> & Reg6 { & self . reg6 }
#[doc = "0x1c - User-defined"]
#[inline (always)] pub const fn reg7 (& self) -> & Reg7 { & self . reg7 }
#[doc = "0x20 - User-defined"]
#[inline (always)] pub const fn reg8 (& self) -> & Reg8 { & self . reg8 }
#[doc = "0x24 - User-defined"]
#[inline (always)] pub const fn reg9 (& self) -> & Reg9 { & self . reg9 }
#[doc = "0x28 - User-defined"]
#[inline (always)] pub const fn reg10 (& self) -> & Reg10 { & self . reg10 }
#[doc = "0x2c - User-defined"]
#[inline (always)] pub const fn reg11 (& self) -> & Reg11 { & self . reg11 }
#[doc = "0x30 - User-defined"]
#[inline (always)] pub const fn reg12 (& self) -> & Reg12 { & self . reg12 }
#[doc = "0x34 - User-defined"]
#[inline (always)] pub const fn reg13 (& self) -> & Reg13 { & self . reg13 }
#[doc = "0x38 - User-defined"]
#[inline (always)] pub const fn reg14 (& self) -> & Reg14 { & self . reg14 }
#[doc = "0x3c - User-defined"]
#[inline (always)] pub const fn reg15 (& self) -> & Reg15 { & self . reg15 }
#[doc = "0x40 - User-defined"]
#[inline (always)] pub const fn reg16 (& self) -> & Reg16 { & self . reg16 }
#[doc = "0x44 - User-defined"]
#[inline (always)] pub const fn reg17 (& self) -> & Reg17 { & self . reg17 }
#[doc = "0x48 - User-defined"]
#[inline (always)] pub const fn reg18 (& self) -> & Reg18 { & self . reg18 }
#[doc = "0x4c - User-defined"]
#[inline (always)] pub const fn reg19 (& self) -> & Reg19 { & self . reg19 }
#[doc = "0x50 - User-defined"]
#[inline (always)] pub const fn reg20 (& self) -> & Reg20 { & self . reg20 }
#[doc = "0x54 - User-defined"]
#[inline (always)] pub const fn reg21 (& self) -> & Reg21 { & self . reg21 }
#[doc = "0x58 - User-defined"]
#[inline (always)] pub const fn reg22 (& self) -> & Reg22 { & self . reg22 }
#[doc = "0x5c - User-defined"]
#[inline (always)] pub const fn reg23 (& self) -> & Reg23 { & self . reg23 }
#[doc = "0x60 - User-defined"]
#[inline (always)] pub const fn reg24 (& self) -> & Reg24 { & self . reg24 }
#[doc = "0x64 - User-defined"]
#[inline (always)] pub const fn reg25 (& self) -> & Reg25 { & self . reg25 }
#[doc = "0x68 - User-defined"]
#[inline (always)] pub const fn reg26 (& self) -> & Reg26 { & self . reg26 }
#[doc = "0x6c - User-defined"]
#[inline (always)] pub const fn reg27 (& self) -> & Reg27 { & self . reg27 }
#[doc = "0x70 - User-defined"]
#[inline (always)] pub const fn reg28 (& self) -> & Reg28 { & self . reg28 }
#[doc = "0x74 - User-defined"]
#[inline (always)] pub const fn reg29 (& self) -> & Reg29 { & self . reg29 }
#[doc = "0x78 - User-defined"]
#[inline (always)] pub const fn reg30 (& self) -> & Reg30 { & self . reg30 }
#[doc = "0x7c - User-defined"]
#[inline (always)] pub const fn reg31 (& self) -> & Reg31 { & self . reg31 }
#[doc = "0x80 - User-defined"]
#[inline (always)] pub const fn reg32 (& self) -> & Reg32 { & self . reg32 }
#[doc = "0x84 - User-defined"]
#[inline (always)] pub const fn reg33 (& self) -> & Reg33 { & self . reg33 }
#[doc = "0x88 - User-defined"]
#[inline (always)] pub const fn reg34 (& self) -> & Reg34 { & self . reg34 }
#[doc = "0x8c - User-defined"]
#[inline (always)] pub const fn reg35 (& self) -> & Reg35 { & self . reg35 }
#[doc = "0x90 - User-defined"]
#[inline (always)] pub const fn reg36 (& self) -> & Reg36 { & self . reg36 }
#[doc = "0x94 - User-defined"]
#[inline (always)] pub const fn reg37 (& self) -> & Reg37 { & self . reg37 }
#[doc = "0x98 - User-defined"]
#[inline (always)] pub const fn reg38 (& self) -> & Reg38 { & self . reg38 }
#[doc = "0x9c - User-defined"]
#[inline (always)] pub const fn reg39 (& self) -> & Reg39 { & self . reg39 }
#[doc = "0xa0 - User-defined"]
#[inline (always)] pub const fn reg40 (& self) -> & Reg40 { & self . reg40 }
#[doc = "0xa4 - User-defined"]
#[inline (always)] pub const fn reg41 (& self) -> & Reg41 { & self . reg41 }
#[doc = "0xa8 - User-defined"]
#[inline (always)] pub const fn reg42 (& self) -> & Reg42 { & self . reg42 }
#[doc = "0xac - User-defined"]
#[inline (always)] pub const fn reg43 (& self) -> & Reg43 { & self . reg43 }
#[doc = "0xb0 - User-defined"]
#[inline (always)] pub const fn reg44 (& self) -> & Reg44 { & self . reg44 }
#[doc = "0xb4 - User-defined"]
#[inline (always)] pub const fn reg45 (& self) -> & Reg45 { & self . reg45 }
#[doc = "0xb8 - User-defined"]
#[inline (always)] pub const fn reg46 (& self) -> & Reg46 { & self . reg46 }
#[doc = "0xbc - User-defined"]
#[inline (always)] pub const fn reg47 (& self) -> & Reg47 { & self . reg47 }
#[doc = "0xc0 - User-defined"]
#[inline (always)] pub const fn reg48 (& self) -> & Reg48 { & self . reg48 }
#[doc = "0xc4 - User-defined"]
#[inline (always)] pub const fn reg49 (& self) -> & Reg49 { & self . reg49 }
#[doc = "0xc8 - User-defined"]
#[inline (always)] pub const fn reg50 (& self) -> & Reg50 { & self . reg50 }
#[doc = "0xcc - User-defined"]
#[inline (always)] pub const fn reg51 (& self) -> & Reg51 { & self . reg51 }
#[doc = "0xd0 - User-defined"]
#[inline (always)] pub const fn reg52 (& self) -> & Reg52 { & self . reg52 }
#[doc = "0xd4 - User-defined"]
#[inline (always)] pub const fn reg53 (& self) -> & Reg53 { & self . reg53 }
#[doc = "0xd8 - User-defined"]
#[inline (always)] pub const fn reg54 (& self) -> & Reg54 { & self . reg54 }
#[doc = "0xdc - User-defined"]
#[inline (always)] pub const fn reg55 (& self) -> & Reg55 { & self . reg55 }
#[doc = "0xe0 - User-defined"]
#[inline (always)] pub const fn reg56 (& self) -> & Reg56 { & self . reg56 }
#[doc = "0xe4 - User-defined"]
#[inline (always)] pub const fn reg57 (& self) -> & Reg57 { & self . reg57 }
#[doc = "0xe8 - User-defined"]
#[inline (always)] pub const fn reg58 (& self) -> & Reg58 { & self . reg58 }
#[doc = "0xec - User-defined"]
#[inline (always)] pub const fn reg59 (& self) -> & Reg59 { & self . reg59 }
#[doc = "0xf0 - User-defined"]
#[inline (always)] pub const fn reg60 (& self) -> & Reg60 { & self . reg60 }
#[doc = "0xf4 - User-defined"]
#[inline (always)] pub const fn reg61 (& self) -> & Reg61 { & self . reg61 }
#[doc = "0xf8 - User-defined"]
#[inline (always)] pub const fn reg62 (& self) -> & Reg62 { & self . reg62 }
#[doc = "0xfc - User-defined"]
#[inline (always)] pub const fn reg63 (& self) -> & Reg63 { & self . reg63 } }
#[doc = "REG0 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg0`] module"]
#[doc (alias = "REG0")] pub type Reg0 = crate :: Reg < reg0 :: Reg0Spec > ;
#[doc = "User-defined"] pub mod reg0 {
#[doc = "Register `REG0` reader"] pub type R = crate :: R < Reg0Spec > ;
#[doc = "Register `REG0` writer"] pub type W = crate :: W < Reg0Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg0Spec ; impl crate :: RegisterSpec for Reg0Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg0::R`](R) reader structure"] impl crate :: Readable for Reg0Spec { }
#[doc = "`write(|w| ..)` method takes [`reg0::W`](W) writer structure"] impl crate :: Writable for Reg0Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG0 to value 0"] impl crate :: Resettable for Reg0Spec { } }
#[doc = "REG1 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg1`] module"]
#[doc (alias = "REG1")] pub type Reg1 = crate :: Reg < reg1 :: Reg1Spec > ;
#[doc = "User-defined"] pub mod reg1 {
#[doc = "Register `REG1` reader"] pub type R = crate :: R < Reg1Spec > ;
#[doc = "Register `REG1` writer"] pub type W = crate :: W < Reg1Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg1Spec ; impl crate :: RegisterSpec for Reg1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg1::R`](R) reader structure"] impl crate :: Readable for Reg1Spec { }
#[doc = "`write(|w| ..)` method takes [`reg1::W`](W) writer structure"] impl crate :: Writable for Reg1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG1 to value 0"] impl crate :: Resettable for Reg1Spec { } }
#[doc = "REG2 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg2`] module"]
#[doc (alias = "REG2")] pub type Reg2 = crate :: Reg < reg2 :: Reg2Spec > ;
#[doc = "User-defined"] pub mod reg2 {
#[doc = "Register `REG2` reader"] pub type R = crate :: R < Reg2Spec > ;
#[doc = "Register `REG2` writer"] pub type W = crate :: W < Reg2Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg2Spec ; impl crate :: RegisterSpec for Reg2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg2::R`](R) reader structure"] impl crate :: Readable for Reg2Spec { }
#[doc = "`write(|w| ..)` method takes [`reg2::W`](W) writer structure"] impl crate :: Writable for Reg2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG2 to value 0"] impl crate :: Resettable for Reg2Spec { } }
#[doc = "REG3 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg3`] module"]
#[doc (alias = "REG3")] pub type Reg3 = crate :: Reg < reg3 :: Reg3Spec > ;
#[doc = "User-defined"] pub mod reg3 {
#[doc = "Register `REG3` reader"] pub type R = crate :: R < Reg3Spec > ;
#[doc = "Register `REG3` writer"] pub type W = crate :: W < Reg3Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg3Spec ; impl crate :: RegisterSpec for Reg3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg3::R`](R) reader structure"] impl crate :: Readable for Reg3Spec { }
#[doc = "`write(|w| ..)` method takes [`reg3::W`](W) writer structure"] impl crate :: Writable for Reg3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG3 to value 0"] impl crate :: Resettable for Reg3Spec { } }
#[doc = "REG4 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg4`] module"]
#[doc (alias = "REG4")] pub type Reg4 = crate :: Reg < reg4 :: Reg4Spec > ;
#[doc = "User-defined"] pub mod reg4 {
#[doc = "Register `REG4` reader"] pub type R = crate :: R < Reg4Spec > ;
#[doc = "Register `REG4` writer"] pub type W = crate :: W < Reg4Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg4Spec ; impl crate :: RegisterSpec for Reg4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg4::R`](R) reader structure"] impl crate :: Readable for Reg4Spec { }
#[doc = "`write(|w| ..)` method takes [`reg4::W`](W) writer structure"] impl crate :: Writable for Reg4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG4 to value 0"] impl crate :: Resettable for Reg4Spec { } }
#[doc = "REG5 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg5::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg5::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg5`] module"]
#[doc (alias = "REG5")] pub type Reg5 = crate :: Reg < reg5 :: Reg5Spec > ;
#[doc = "User-defined"] pub mod reg5 {
#[doc = "Register `REG5` reader"] pub type R = crate :: R < Reg5Spec > ;
#[doc = "Register `REG5` writer"] pub type W = crate :: W < Reg5Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg5::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg5::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg5Spec ; impl crate :: RegisterSpec for Reg5Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg5::R`](R) reader structure"] impl crate :: Readable for Reg5Spec { }
#[doc = "`write(|w| ..)` method takes [`reg5::W`](W) writer structure"] impl crate :: Writable for Reg5Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG5 to value 0"] impl crate :: Resettable for Reg5Spec { } }
#[doc = "REG6 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg6::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg6::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg6`] module"]
#[doc (alias = "REG6")] pub type Reg6 = crate :: Reg < reg6 :: Reg6Spec > ;
#[doc = "User-defined"] pub mod reg6 {
#[doc = "Register `REG6` reader"] pub type R = crate :: R < Reg6Spec > ;
#[doc = "Register `REG6` writer"] pub type W = crate :: W < Reg6Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg6::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg6::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg6Spec ; impl crate :: RegisterSpec for Reg6Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg6::R`](R) reader structure"] impl crate :: Readable for Reg6Spec { }
#[doc = "`write(|w| ..)` method takes [`reg6::W`](W) writer structure"] impl crate :: Writable for Reg6Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG6 to value 0"] impl crate :: Resettable for Reg6Spec { } }
#[doc = "REG7 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg7::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg7::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg7`] module"]
#[doc (alias = "REG7")] pub type Reg7 = crate :: Reg < reg7 :: Reg7Spec > ;
#[doc = "User-defined"] pub mod reg7 {
#[doc = "Register `REG7` reader"] pub type R = crate :: R < Reg7Spec > ;
#[doc = "Register `REG7` writer"] pub type W = crate :: W < Reg7Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg7::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg7::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg7Spec ; impl crate :: RegisterSpec for Reg7Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg7::R`](R) reader structure"] impl crate :: Readable for Reg7Spec { }
#[doc = "`write(|w| ..)` method takes [`reg7::W`](W) writer structure"] impl crate :: Writable for Reg7Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG7 to value 0"] impl crate :: Resettable for Reg7Spec { } }
#[doc = "REG8 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg8::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg8::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg8`] module"]
#[doc (alias = "REG8")] pub type Reg8 = crate :: Reg < reg8 :: Reg8Spec > ;
#[doc = "User-defined"] pub mod reg8 {
#[doc = "Register `REG8` reader"] pub type R = crate :: R < Reg8Spec > ;
#[doc = "Register `REG8` writer"] pub type W = crate :: W < Reg8Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg8::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg8::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg8Spec ; impl crate :: RegisterSpec for Reg8Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg8::R`](R) reader structure"] impl crate :: Readable for Reg8Spec { }
#[doc = "`write(|w| ..)` method takes [`reg8::W`](W) writer structure"] impl crate :: Writable for Reg8Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG8 to value 0"] impl crate :: Resettable for Reg8Spec { } }
#[doc = "REG9 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg9::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg9::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg9`] module"]
#[doc (alias = "REG9")] pub type Reg9 = crate :: Reg < reg9 :: Reg9Spec > ;
#[doc = "User-defined"] pub mod reg9 {
#[doc = "Register `REG9` reader"] pub type R = crate :: R < Reg9Spec > ;
#[doc = "Register `REG9` writer"] pub type W = crate :: W < Reg9Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg9::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg9::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg9Spec ; impl crate :: RegisterSpec for Reg9Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg9::R`](R) reader structure"] impl crate :: Readable for Reg9Spec { }
#[doc = "`write(|w| ..)` method takes [`reg9::W`](W) writer structure"] impl crate :: Writable for Reg9Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG9 to value 0"] impl crate :: Resettable for Reg9Spec { } }
#[doc = "REG10 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg10::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg10::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg10`] module"]
#[doc (alias = "REG10")] pub type Reg10 = crate :: Reg < reg10 :: Reg10Spec > ;
#[doc = "User-defined"] pub mod reg10 {
#[doc = "Register `REG10` reader"] pub type R = crate :: R < Reg10Spec > ;
#[doc = "Register `REG10` writer"] pub type W = crate :: W < Reg10Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg10::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg10::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg10Spec ; impl crate :: RegisterSpec for Reg10Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg10::R`](R) reader structure"] impl crate :: Readable for Reg10Spec { }
#[doc = "`write(|w| ..)` method takes [`reg10::W`](W) writer structure"] impl crate :: Writable for Reg10Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG10 to value 0"] impl crate :: Resettable for Reg10Spec { } }
#[doc = "REG11 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg11::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg11::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg11`] module"]
#[doc (alias = "REG11")] pub type Reg11 = crate :: Reg < reg11 :: Reg11Spec > ;
#[doc = "User-defined"] pub mod reg11 {
#[doc = "Register `REG11` reader"] pub type R = crate :: R < Reg11Spec > ;
#[doc = "Register `REG11` writer"] pub type W = crate :: W < Reg11Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg11::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg11::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg11Spec ; impl crate :: RegisterSpec for Reg11Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg11::R`](R) reader structure"] impl crate :: Readable for Reg11Spec { }
#[doc = "`write(|w| ..)` method takes [`reg11::W`](W) writer structure"] impl crate :: Writable for Reg11Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG11 to value 0"] impl crate :: Resettable for Reg11Spec { } }
#[doc = "REG12 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg12::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg12::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg12`] module"]
#[doc (alias = "REG12")] pub type Reg12 = crate :: Reg < reg12 :: Reg12Spec > ;
#[doc = "User-defined"] pub mod reg12 {
#[doc = "Register `REG12` reader"] pub type R = crate :: R < Reg12Spec > ;
#[doc = "Register `REG12` writer"] pub type W = crate :: W < Reg12Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg12::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg12::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg12Spec ; impl crate :: RegisterSpec for Reg12Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg12::R`](R) reader structure"] impl crate :: Readable for Reg12Spec { }
#[doc = "`write(|w| ..)` method takes [`reg12::W`](W) writer structure"] impl crate :: Writable for Reg12Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG12 to value 0"] impl crate :: Resettable for Reg12Spec { } }
#[doc = "REG13 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg13::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg13::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg13`] module"]
#[doc (alias = "REG13")] pub type Reg13 = crate :: Reg < reg13 :: Reg13Spec > ;
#[doc = "User-defined"] pub mod reg13 {
#[doc = "Register `REG13` reader"] pub type R = crate :: R < Reg13Spec > ;
#[doc = "Register `REG13` writer"] pub type W = crate :: W < Reg13Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg13::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg13::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg13Spec ; impl crate :: RegisterSpec for Reg13Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg13::R`](R) reader structure"] impl crate :: Readable for Reg13Spec { }
#[doc = "`write(|w| ..)` method takes [`reg13::W`](W) writer structure"] impl crate :: Writable for Reg13Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG13 to value 0"] impl crate :: Resettable for Reg13Spec { } }
#[doc = "REG14 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg14::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg14::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg14`] module"]
#[doc (alias = "REG14")] pub type Reg14 = crate :: Reg < reg14 :: Reg14Spec > ;
#[doc = "User-defined"] pub mod reg14 {
#[doc = "Register `REG14` reader"] pub type R = crate :: R < Reg14Spec > ;
#[doc = "Register `REG14` writer"] pub type W = crate :: W < Reg14Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg14::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg14::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg14Spec ; impl crate :: RegisterSpec for Reg14Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg14::R`](R) reader structure"] impl crate :: Readable for Reg14Spec { }
#[doc = "`write(|w| ..)` method takes [`reg14::W`](W) writer structure"] impl crate :: Writable for Reg14Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG14 to value 0"] impl crate :: Resettable for Reg14Spec { } }
#[doc = "REG15 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg15::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg15::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg15`] module"]
#[doc (alias = "REG15")] pub type Reg15 = crate :: Reg < reg15 :: Reg15Spec > ;
#[doc = "User-defined"] pub mod reg15 {
#[doc = "Register `REG15` reader"] pub type R = crate :: R < Reg15Spec > ;
#[doc = "Register `REG15` writer"] pub type W = crate :: W < Reg15Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg15::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg15::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg15Spec ; impl crate :: RegisterSpec for Reg15Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg15::R`](R) reader structure"] impl crate :: Readable for Reg15Spec { }
#[doc = "`write(|w| ..)` method takes [`reg15::W`](W) writer structure"] impl crate :: Writable for Reg15Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG15 to value 0"] impl crate :: Resettable for Reg15Spec { } }
#[doc = "REG16 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg16::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg16::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg16`] module"]
#[doc (alias = "REG16")] pub type Reg16 = crate :: Reg < reg16 :: Reg16Spec > ;
#[doc = "User-defined"] pub mod reg16 {
#[doc = "Register `REG16` reader"] pub type R = crate :: R < Reg16Spec > ;
#[doc = "Register `REG16` writer"] pub type W = crate :: W < Reg16Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg16::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg16::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg16Spec ; impl crate :: RegisterSpec for Reg16Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg16::R`](R) reader structure"] impl crate :: Readable for Reg16Spec { }
#[doc = "`write(|w| ..)` method takes [`reg16::W`](W) writer structure"] impl crate :: Writable for Reg16Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG16 to value 0"] impl crate :: Resettable for Reg16Spec { } }
#[doc = "REG17 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg17::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg17::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg17`] module"]
#[doc (alias = "REG17")] pub type Reg17 = crate :: Reg < reg17 :: Reg17Spec > ;
#[doc = "User-defined"] pub mod reg17 {
#[doc = "Register `REG17` reader"] pub type R = crate :: R < Reg17Spec > ;
#[doc = "Register `REG17` writer"] pub type W = crate :: W < Reg17Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg17::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg17::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg17Spec ; impl crate :: RegisterSpec for Reg17Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg17::R`](R) reader structure"] impl crate :: Readable for Reg17Spec { }
#[doc = "`write(|w| ..)` method takes [`reg17::W`](W) writer structure"] impl crate :: Writable for Reg17Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG17 to value 0"] impl crate :: Resettable for Reg17Spec { } }
#[doc = "REG18 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg18::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg18::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg18`] module"]
#[doc (alias = "REG18")] pub type Reg18 = crate :: Reg < reg18 :: Reg18Spec > ;
#[doc = "User-defined"] pub mod reg18 {
#[doc = "Register `REG18` reader"] pub type R = crate :: R < Reg18Spec > ;
#[doc = "Register `REG18` writer"] pub type W = crate :: W < Reg18Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg18::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg18::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg18Spec ; impl crate :: RegisterSpec for Reg18Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg18::R`](R) reader structure"] impl crate :: Readable for Reg18Spec { }
#[doc = "`write(|w| ..)` method takes [`reg18::W`](W) writer structure"] impl crate :: Writable for Reg18Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG18 to value 0"] impl crate :: Resettable for Reg18Spec { } }
#[doc = "REG19 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg19::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg19::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg19`] module"]
#[doc (alias = "REG19")] pub type Reg19 = crate :: Reg < reg19 :: Reg19Spec > ;
#[doc = "User-defined"] pub mod reg19 {
#[doc = "Register `REG19` reader"] pub type R = crate :: R < Reg19Spec > ;
#[doc = "Register `REG19` writer"] pub type W = crate :: W < Reg19Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg19::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg19::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg19Spec ; impl crate :: RegisterSpec for Reg19Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg19::R`](R) reader structure"] impl crate :: Readable for Reg19Spec { }
#[doc = "`write(|w| ..)` method takes [`reg19::W`](W) writer structure"] impl crate :: Writable for Reg19Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG19 to value 0"] impl crate :: Resettable for Reg19Spec { } }
#[doc = "REG20 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg20::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg20::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg20`] module"]
#[doc (alias = "REG20")] pub type Reg20 = crate :: Reg < reg20 :: Reg20Spec > ;
#[doc = "User-defined"] pub mod reg20 {
#[doc = "Register `REG20` reader"] pub type R = crate :: R < Reg20Spec > ;
#[doc = "Register `REG20` writer"] pub type W = crate :: W < Reg20Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg20::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg20::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg20Spec ; impl crate :: RegisterSpec for Reg20Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg20::R`](R) reader structure"] impl crate :: Readable for Reg20Spec { }
#[doc = "`write(|w| ..)` method takes [`reg20::W`](W) writer structure"] impl crate :: Writable for Reg20Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG20 to value 0"] impl crate :: Resettable for Reg20Spec { } }
#[doc = "REG21 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg21::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg21::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg21`] module"]
#[doc (alias = "REG21")] pub type Reg21 = crate :: Reg < reg21 :: Reg21Spec > ;
#[doc = "User-defined"] pub mod reg21 {
#[doc = "Register `REG21` reader"] pub type R = crate :: R < Reg21Spec > ;
#[doc = "Register `REG21` writer"] pub type W = crate :: W < Reg21Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg21::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg21::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg21Spec ; impl crate :: RegisterSpec for Reg21Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg21::R`](R) reader structure"] impl crate :: Readable for Reg21Spec { }
#[doc = "`write(|w| ..)` method takes [`reg21::W`](W) writer structure"] impl crate :: Writable for Reg21Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG21 to value 0"] impl crate :: Resettable for Reg21Spec { } }
#[doc = "REG22 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg22::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg22::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg22`] module"]
#[doc (alias = "REG22")] pub type Reg22 = crate :: Reg < reg22 :: Reg22Spec > ;
#[doc = "User-defined"] pub mod reg22 {
#[doc = "Register `REG22` reader"] pub type R = crate :: R < Reg22Spec > ;
#[doc = "Register `REG22` writer"] pub type W = crate :: W < Reg22Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg22::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg22::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg22Spec ; impl crate :: RegisterSpec for Reg22Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg22::R`](R) reader structure"] impl crate :: Readable for Reg22Spec { }
#[doc = "`write(|w| ..)` method takes [`reg22::W`](W) writer structure"] impl crate :: Writable for Reg22Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG22 to value 0"] impl crate :: Resettable for Reg22Spec { } }
#[doc = "REG23 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg23::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg23::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg23`] module"]
#[doc (alias = "REG23")] pub type Reg23 = crate :: Reg < reg23 :: Reg23Spec > ;
#[doc = "User-defined"] pub mod reg23 {
#[doc = "Register `REG23` reader"] pub type R = crate :: R < Reg23Spec > ;
#[doc = "Register `REG23` writer"] pub type W = crate :: W < Reg23Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg23::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg23::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg23Spec ; impl crate :: RegisterSpec for Reg23Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg23::R`](R) reader structure"] impl crate :: Readable for Reg23Spec { }
#[doc = "`write(|w| ..)` method takes [`reg23::W`](W) writer structure"] impl crate :: Writable for Reg23Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG23 to value 0"] impl crate :: Resettable for Reg23Spec { } }
#[doc = "REG24 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg24::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg24::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg24`] module"]
#[doc (alias = "REG24")] pub type Reg24 = crate :: Reg < reg24 :: Reg24Spec > ;
#[doc = "User-defined"] pub mod reg24 {
#[doc = "Register `REG24` reader"] pub type R = crate :: R < Reg24Spec > ;
#[doc = "Register `REG24` writer"] pub type W = crate :: W < Reg24Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg24::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg24::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg24Spec ; impl crate :: RegisterSpec for Reg24Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg24::R`](R) reader structure"] impl crate :: Readable for Reg24Spec { }
#[doc = "`write(|w| ..)` method takes [`reg24::W`](W) writer structure"] impl crate :: Writable for Reg24Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG24 to value 0"] impl crate :: Resettable for Reg24Spec { } }
#[doc = "REG25 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg25::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg25::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg25`] module"]
#[doc (alias = "REG25")] pub type Reg25 = crate :: Reg < reg25 :: Reg25Spec > ;
#[doc = "User-defined"] pub mod reg25 {
#[doc = "Register `REG25` reader"] pub type R = crate :: R < Reg25Spec > ;
#[doc = "Register `REG25` writer"] pub type W = crate :: W < Reg25Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg25::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg25::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg25Spec ; impl crate :: RegisterSpec for Reg25Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg25::R`](R) reader structure"] impl crate :: Readable for Reg25Spec { }
#[doc = "`write(|w| ..)` method takes [`reg25::W`](W) writer structure"] impl crate :: Writable for Reg25Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG25 to value 0"] impl crate :: Resettable for Reg25Spec { } }
#[doc = "REG26 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg26::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg26::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg26`] module"]
#[doc (alias = "REG26")] pub type Reg26 = crate :: Reg < reg26 :: Reg26Spec > ;
#[doc = "User-defined"] pub mod reg26 {
#[doc = "Register `REG26` reader"] pub type R = crate :: R < Reg26Spec > ;
#[doc = "Register `REG26` writer"] pub type W = crate :: W < Reg26Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg26::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg26::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg26Spec ; impl crate :: RegisterSpec for Reg26Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg26::R`](R) reader structure"] impl crate :: Readable for Reg26Spec { }
#[doc = "`write(|w| ..)` method takes [`reg26::W`](W) writer structure"] impl crate :: Writable for Reg26Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG26 to value 0"] impl crate :: Resettable for Reg26Spec { } }
#[doc = "REG27 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg27::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg27::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg27`] module"]
#[doc (alias = "REG27")] pub type Reg27 = crate :: Reg < reg27 :: Reg27Spec > ;
#[doc = "User-defined"] pub mod reg27 {
#[doc = "Register `REG27` reader"] pub type R = crate :: R < Reg27Spec > ;
#[doc = "Register `REG27` writer"] pub type W = crate :: W < Reg27Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg27::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg27::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg27Spec ; impl crate :: RegisterSpec for Reg27Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg27::R`](R) reader structure"] impl crate :: Readable for Reg27Spec { }
#[doc = "`write(|w| ..)` method takes [`reg27::W`](W) writer structure"] impl crate :: Writable for Reg27Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG27 to value 0"] impl crate :: Resettable for Reg27Spec { } }
#[doc = "REG28 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg28::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg28::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg28`] module"]
#[doc (alias = "REG28")] pub type Reg28 = crate :: Reg < reg28 :: Reg28Spec > ;
#[doc = "User-defined"] pub mod reg28 {
#[doc = "Register `REG28` reader"] pub type R = crate :: R < Reg28Spec > ;
#[doc = "Register `REG28` writer"] pub type W = crate :: W < Reg28Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg28::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg28::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg28Spec ; impl crate :: RegisterSpec for Reg28Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg28::R`](R) reader structure"] impl crate :: Readable for Reg28Spec { }
#[doc = "`write(|w| ..)` method takes [`reg28::W`](W) writer structure"] impl crate :: Writable for Reg28Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG28 to value 0"] impl crate :: Resettable for Reg28Spec { } }
#[doc = "REG29 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg29::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg29::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg29`] module"]
#[doc (alias = "REG29")] pub type Reg29 = crate :: Reg < reg29 :: Reg29Spec > ;
#[doc = "User-defined"] pub mod reg29 {
#[doc = "Register `REG29` reader"] pub type R = crate :: R < Reg29Spec > ;
#[doc = "Register `REG29` writer"] pub type W = crate :: W < Reg29Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg29::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg29::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg29Spec ; impl crate :: RegisterSpec for Reg29Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg29::R`](R) reader structure"] impl crate :: Readable for Reg29Spec { }
#[doc = "`write(|w| ..)` method takes [`reg29::W`](W) writer structure"] impl crate :: Writable for Reg29Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG29 to value 0"] impl crate :: Resettable for Reg29Spec { } }
#[doc = "REG30 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg30::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg30::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg30`] module"]
#[doc (alias = "REG30")] pub type Reg30 = crate :: Reg < reg30 :: Reg30Spec > ;
#[doc = "User-defined"] pub mod reg30 {
#[doc = "Register `REG30` reader"] pub type R = crate :: R < Reg30Spec > ;
#[doc = "Register `REG30` writer"] pub type W = crate :: W < Reg30Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg30::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg30::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg30Spec ; impl crate :: RegisterSpec for Reg30Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg30::R`](R) reader structure"] impl crate :: Readable for Reg30Spec { }
#[doc = "`write(|w| ..)` method takes [`reg30::W`](W) writer structure"] impl crate :: Writable for Reg30Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG30 to value 0"] impl crate :: Resettable for Reg30Spec { } }
#[doc = "REG31 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg31::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg31::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg31`] module"]
#[doc (alias = "REG31")] pub type Reg31 = crate :: Reg < reg31 :: Reg31Spec > ;
#[doc = "User-defined"] pub mod reg31 {
#[doc = "Register `REG31` reader"] pub type R = crate :: R < Reg31Spec > ;
#[doc = "Register `REG31` writer"] pub type W = crate :: W < Reg31Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg31::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg31::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg31Spec ; impl crate :: RegisterSpec for Reg31Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg31::R`](R) reader structure"] impl crate :: Readable for Reg31Spec { }
#[doc = "`write(|w| ..)` method takes [`reg31::W`](W) writer structure"] impl crate :: Writable for Reg31Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG31 to value 0"] impl crate :: Resettable for Reg31Spec { } }
#[doc = "REG32 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg32::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg32::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg32`] module"]
#[doc (alias = "REG32")] pub type Reg32 = crate :: Reg < reg32 :: Reg32Spec > ;
#[doc = "User-defined"] pub mod reg32 {
#[doc = "Register `REG32` reader"] pub type R = crate :: R < Reg32Spec > ;
#[doc = "Register `REG32` writer"] pub type W = crate :: W < Reg32Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg32::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg32::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg32Spec ; impl crate :: RegisterSpec for Reg32Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg32::R`](R) reader structure"] impl crate :: Readable for Reg32Spec { }
#[doc = "`write(|w| ..)` method takes [`reg32::W`](W) writer structure"] impl crate :: Writable for Reg32Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG32 to value 0"] impl crate :: Resettable for Reg32Spec { } }
#[doc = "REG33 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg33::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg33::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg33`] module"]
#[doc (alias = "REG33")] pub type Reg33 = crate :: Reg < reg33 :: Reg33Spec > ;
#[doc = "User-defined"] pub mod reg33 {
#[doc = "Register `REG33` reader"] pub type R = crate :: R < Reg33Spec > ;
#[doc = "Register `REG33` writer"] pub type W = crate :: W < Reg33Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg33::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg33::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg33Spec ; impl crate :: RegisterSpec for Reg33Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg33::R`](R) reader structure"] impl crate :: Readable for Reg33Spec { }
#[doc = "`write(|w| ..)` method takes [`reg33::W`](W) writer structure"] impl crate :: Writable for Reg33Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG33 to value 0"] impl crate :: Resettable for Reg33Spec { } }
#[doc = "REG34 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg34::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg34::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg34`] module"]
#[doc (alias = "REG34")] pub type Reg34 = crate :: Reg < reg34 :: Reg34Spec > ;
#[doc = "User-defined"] pub mod reg34 {
#[doc = "Register `REG34` reader"] pub type R = crate :: R < Reg34Spec > ;
#[doc = "Register `REG34` writer"] pub type W = crate :: W < Reg34Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg34::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg34::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg34Spec ; impl crate :: RegisterSpec for Reg34Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg34::R`](R) reader structure"] impl crate :: Readable for Reg34Spec { }
#[doc = "`write(|w| ..)` method takes [`reg34::W`](W) writer structure"] impl crate :: Writable for Reg34Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG34 to value 0"] impl crate :: Resettable for Reg34Spec { } }
#[doc = "REG35 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg35::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg35::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg35`] module"]
#[doc (alias = "REG35")] pub type Reg35 = crate :: Reg < reg35 :: Reg35Spec > ;
#[doc = "User-defined"] pub mod reg35 {
#[doc = "Register `REG35` reader"] pub type R = crate :: R < Reg35Spec > ;
#[doc = "Register `REG35` writer"] pub type W = crate :: W < Reg35Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg35::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg35::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg35Spec ; impl crate :: RegisterSpec for Reg35Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg35::R`](R) reader structure"] impl crate :: Readable for Reg35Spec { }
#[doc = "`write(|w| ..)` method takes [`reg35::W`](W) writer structure"] impl crate :: Writable for Reg35Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG35 to value 0"] impl crate :: Resettable for Reg35Spec { } }
#[doc = "REG36 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg36::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg36::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg36`] module"]
#[doc (alias = "REG36")] pub type Reg36 = crate :: Reg < reg36 :: Reg36Spec > ;
#[doc = "User-defined"] pub mod reg36 {
#[doc = "Register `REG36` reader"] pub type R = crate :: R < Reg36Spec > ;
#[doc = "Register `REG36` writer"] pub type W = crate :: W < Reg36Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg36::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg36::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg36Spec ; impl crate :: RegisterSpec for Reg36Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg36::R`](R) reader structure"] impl crate :: Readable for Reg36Spec { }
#[doc = "`write(|w| ..)` method takes [`reg36::W`](W) writer structure"] impl crate :: Writable for Reg36Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG36 to value 0"] impl crate :: Resettable for Reg36Spec { } }
#[doc = "REG37 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg37::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg37::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg37`] module"]
#[doc (alias = "REG37")] pub type Reg37 = crate :: Reg < reg37 :: Reg37Spec > ;
#[doc = "User-defined"] pub mod reg37 {
#[doc = "Register `REG37` reader"] pub type R = crate :: R < Reg37Spec > ;
#[doc = "Register `REG37` writer"] pub type W = crate :: W < Reg37Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg37::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg37::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg37Spec ; impl crate :: RegisterSpec for Reg37Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg37::R`](R) reader structure"] impl crate :: Readable for Reg37Spec { }
#[doc = "`write(|w| ..)` method takes [`reg37::W`](W) writer structure"] impl crate :: Writable for Reg37Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG37 to value 0"] impl crate :: Resettable for Reg37Spec { } }
#[doc = "REG38 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg38::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg38::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg38`] module"]
#[doc (alias = "REG38")] pub type Reg38 = crate :: Reg < reg38 :: Reg38Spec > ;
#[doc = "User-defined"] pub mod reg38 {
#[doc = "Register `REG38` reader"] pub type R = crate :: R < Reg38Spec > ;
#[doc = "Register `REG38` writer"] pub type W = crate :: W < Reg38Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg38::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg38::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg38Spec ; impl crate :: RegisterSpec for Reg38Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg38::R`](R) reader structure"] impl crate :: Readable for Reg38Spec { }
#[doc = "`write(|w| ..)` method takes [`reg38::W`](W) writer structure"] impl crate :: Writable for Reg38Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG38 to value 0"] impl crate :: Resettable for Reg38Spec { } }
#[doc = "REG39 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg39::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg39::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg39`] module"]
#[doc (alias = "REG39")] pub type Reg39 = crate :: Reg < reg39 :: Reg39Spec > ;
#[doc = "User-defined"] pub mod reg39 {
#[doc = "Register `REG39` reader"] pub type R = crate :: R < Reg39Spec > ;
#[doc = "Register `REG39` writer"] pub type W = crate :: W < Reg39Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg39::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg39::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg39Spec ; impl crate :: RegisterSpec for Reg39Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg39::R`](R) reader structure"] impl crate :: Readable for Reg39Spec { }
#[doc = "`write(|w| ..)` method takes [`reg39::W`](W) writer structure"] impl crate :: Writable for Reg39Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG39 to value 0"] impl crate :: Resettable for Reg39Spec { } }
#[doc = "REG40 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg40::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg40::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg40`] module"]
#[doc (alias = "REG40")] pub type Reg40 = crate :: Reg < reg40 :: Reg40Spec > ;
#[doc = "User-defined"] pub mod reg40 {
#[doc = "Register `REG40` reader"] pub type R = crate :: R < Reg40Spec > ;
#[doc = "Register `REG40` writer"] pub type W = crate :: W < Reg40Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg40::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg40::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg40Spec ; impl crate :: RegisterSpec for Reg40Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg40::R`](R) reader structure"] impl crate :: Readable for Reg40Spec { }
#[doc = "`write(|w| ..)` method takes [`reg40::W`](W) writer structure"] impl crate :: Writable for Reg40Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG40 to value 0"] impl crate :: Resettable for Reg40Spec { } }
#[doc = "REG41 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg41::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg41::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg41`] module"]
#[doc (alias = "REG41")] pub type Reg41 = crate :: Reg < reg41 :: Reg41Spec > ;
#[doc = "User-defined"] pub mod reg41 {
#[doc = "Register `REG41` reader"] pub type R = crate :: R < Reg41Spec > ;
#[doc = "Register `REG41` writer"] pub type W = crate :: W < Reg41Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg41::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg41::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg41Spec ; impl crate :: RegisterSpec for Reg41Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg41::R`](R) reader structure"] impl crate :: Readable for Reg41Spec { }
#[doc = "`write(|w| ..)` method takes [`reg41::W`](W) writer structure"] impl crate :: Writable for Reg41Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG41 to value 0"] impl crate :: Resettable for Reg41Spec { } }
#[doc = "REG42 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg42::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg42::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg42`] module"]
#[doc (alias = "REG42")] pub type Reg42 = crate :: Reg < reg42 :: Reg42Spec > ;
#[doc = "User-defined"] pub mod reg42 {
#[doc = "Register `REG42` reader"] pub type R = crate :: R < Reg42Spec > ;
#[doc = "Register `REG42` writer"] pub type W = crate :: W < Reg42Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg42::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg42::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg42Spec ; impl crate :: RegisterSpec for Reg42Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg42::R`](R) reader structure"] impl crate :: Readable for Reg42Spec { }
#[doc = "`write(|w| ..)` method takes [`reg42::W`](W) writer structure"] impl crate :: Writable for Reg42Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG42 to value 0"] impl crate :: Resettable for Reg42Spec { } }
#[doc = "REG43 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg43::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg43::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg43`] module"]
#[doc (alias = "REG43")] pub type Reg43 = crate :: Reg < reg43 :: Reg43Spec > ;
#[doc = "User-defined"] pub mod reg43 {
#[doc = "Register `REG43` reader"] pub type R = crate :: R < Reg43Spec > ;
#[doc = "Register `REG43` writer"] pub type W = crate :: W < Reg43Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg43::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg43::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg43Spec ; impl crate :: RegisterSpec for Reg43Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg43::R`](R) reader structure"] impl crate :: Readable for Reg43Spec { }
#[doc = "`write(|w| ..)` method takes [`reg43::W`](W) writer structure"] impl crate :: Writable for Reg43Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG43 to value 0"] impl crate :: Resettable for Reg43Spec { } }
#[doc = "REG44 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg44::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg44::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg44`] module"]
#[doc (alias = "REG44")] pub type Reg44 = crate :: Reg < reg44 :: Reg44Spec > ;
#[doc = "User-defined"] pub mod reg44 {
#[doc = "Register `REG44` reader"] pub type R = crate :: R < Reg44Spec > ;
#[doc = "Register `REG44` writer"] pub type W = crate :: W < Reg44Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg44::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg44::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg44Spec ; impl crate :: RegisterSpec for Reg44Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg44::R`](R) reader structure"] impl crate :: Readable for Reg44Spec { }
#[doc = "`write(|w| ..)` method takes [`reg44::W`](W) writer structure"] impl crate :: Writable for Reg44Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG44 to value 0"] impl crate :: Resettable for Reg44Spec { } }
#[doc = "REG45 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg45::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg45::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg45`] module"]
#[doc (alias = "REG45")] pub type Reg45 = crate :: Reg < reg45 :: Reg45Spec > ;
#[doc = "User-defined"] pub mod reg45 {
#[doc = "Register `REG45` reader"] pub type R = crate :: R < Reg45Spec > ;
#[doc = "Register `REG45` writer"] pub type W = crate :: W < Reg45Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg45::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg45::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg45Spec ; impl crate :: RegisterSpec for Reg45Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg45::R`](R) reader structure"] impl crate :: Readable for Reg45Spec { }
#[doc = "`write(|w| ..)` method takes [`reg45::W`](W) writer structure"] impl crate :: Writable for Reg45Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG45 to value 0"] impl crate :: Resettable for Reg45Spec { } }
#[doc = "REG46 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg46::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg46::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg46`] module"]
#[doc (alias = "REG46")] pub type Reg46 = crate :: Reg < reg46 :: Reg46Spec > ;
#[doc = "User-defined"] pub mod reg46 {
#[doc = "Register `REG46` reader"] pub type R = crate :: R < Reg46Spec > ;
#[doc = "Register `REG46` writer"] pub type W = crate :: W < Reg46Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg46::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg46::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg46Spec ; impl crate :: RegisterSpec for Reg46Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg46::R`](R) reader structure"] impl crate :: Readable for Reg46Spec { }
#[doc = "`write(|w| ..)` method takes [`reg46::W`](W) writer structure"] impl crate :: Writable for Reg46Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG46 to value 0"] impl crate :: Resettable for Reg46Spec { } }
#[doc = "REG47 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg47::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg47::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg47`] module"]
#[doc (alias = "REG47")] pub type Reg47 = crate :: Reg < reg47 :: Reg47Spec > ;
#[doc = "User-defined"] pub mod reg47 {
#[doc = "Register `REG47` reader"] pub type R = crate :: R < Reg47Spec > ;
#[doc = "Register `REG47` writer"] pub type W = crate :: W < Reg47Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg47::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg47::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg47Spec ; impl crate :: RegisterSpec for Reg47Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg47::R`](R) reader structure"] impl crate :: Readable for Reg47Spec { }
#[doc = "`write(|w| ..)` method takes [`reg47::W`](W) writer structure"] impl crate :: Writable for Reg47Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG47 to value 0"] impl crate :: Resettable for Reg47Spec { } }
#[doc = "REG48 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg48::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg48::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg48`] module"]
#[doc (alias = "REG48")] pub type Reg48 = crate :: Reg < reg48 :: Reg48Spec > ;
#[doc = "User-defined"] pub mod reg48 {
#[doc = "Register `REG48` reader"] pub type R = crate :: R < Reg48Spec > ;
#[doc = "Register `REG48` writer"] pub type W = crate :: W < Reg48Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg48::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg48::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg48Spec ; impl crate :: RegisterSpec for Reg48Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg48::R`](R) reader structure"] impl crate :: Readable for Reg48Spec { }
#[doc = "`write(|w| ..)` method takes [`reg48::W`](W) writer structure"] impl crate :: Writable for Reg48Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG48 to value 0"] impl crate :: Resettable for Reg48Spec { } }
#[doc = "REG49 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg49::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg49::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg49`] module"]
#[doc (alias = "REG49")] pub type Reg49 = crate :: Reg < reg49 :: Reg49Spec > ;
#[doc = "User-defined"] pub mod reg49 {
#[doc = "Register `REG49` reader"] pub type R = crate :: R < Reg49Spec > ;
#[doc = "Register `REG49` writer"] pub type W = crate :: W < Reg49Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg49::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg49::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg49Spec ; impl crate :: RegisterSpec for Reg49Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg49::R`](R) reader structure"] impl crate :: Readable for Reg49Spec { }
#[doc = "`write(|w| ..)` method takes [`reg49::W`](W) writer structure"] impl crate :: Writable for Reg49Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG49 to value 0"] impl crate :: Resettable for Reg49Spec { } }
#[doc = "REG50 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg50::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg50::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg50`] module"]
#[doc (alias = "REG50")] pub type Reg50 = crate :: Reg < reg50 :: Reg50Spec > ;
#[doc = "User-defined"] pub mod reg50 {
#[doc = "Register `REG50` reader"] pub type R = crate :: R < Reg50Spec > ;
#[doc = "Register `REG50` writer"] pub type W = crate :: W < Reg50Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg50::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg50::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg50Spec ; impl crate :: RegisterSpec for Reg50Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg50::R`](R) reader structure"] impl crate :: Readable for Reg50Spec { }
#[doc = "`write(|w| ..)` method takes [`reg50::W`](W) writer structure"] impl crate :: Writable for Reg50Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG50 to value 0"] impl crate :: Resettable for Reg50Spec { } }
#[doc = "REG51 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg51::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg51::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg51`] module"]
#[doc (alias = "REG51")] pub type Reg51 = crate :: Reg < reg51 :: Reg51Spec > ;
#[doc = "User-defined"] pub mod reg51 {
#[doc = "Register `REG51` reader"] pub type R = crate :: R < Reg51Spec > ;
#[doc = "Register `REG51` writer"] pub type W = crate :: W < Reg51Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg51::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg51::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg51Spec ; impl crate :: RegisterSpec for Reg51Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg51::R`](R) reader structure"] impl crate :: Readable for Reg51Spec { }
#[doc = "`write(|w| ..)` method takes [`reg51::W`](W) writer structure"] impl crate :: Writable for Reg51Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG51 to value 0"] impl crate :: Resettable for Reg51Spec { } }
#[doc = "REG52 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg52::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg52::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg52`] module"]
#[doc (alias = "REG52")] pub type Reg52 = crate :: Reg < reg52 :: Reg52Spec > ;
#[doc = "User-defined"] pub mod reg52 {
#[doc = "Register `REG52` reader"] pub type R = crate :: R < Reg52Spec > ;
#[doc = "Register `REG52` writer"] pub type W = crate :: W < Reg52Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg52::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg52::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg52Spec ; impl crate :: RegisterSpec for Reg52Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg52::R`](R) reader structure"] impl crate :: Readable for Reg52Spec { }
#[doc = "`write(|w| ..)` method takes [`reg52::W`](W) writer structure"] impl crate :: Writable for Reg52Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG52 to value 0"] impl crate :: Resettable for Reg52Spec { } }
#[doc = "REG53 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg53::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg53::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg53`] module"]
#[doc (alias = "REG53")] pub type Reg53 = crate :: Reg < reg53 :: Reg53Spec > ;
#[doc = "User-defined"] pub mod reg53 {
#[doc = "Register `REG53` reader"] pub type R = crate :: R < Reg53Spec > ;
#[doc = "Register `REG53` writer"] pub type W = crate :: W < Reg53Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg53::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg53::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg53Spec ; impl crate :: RegisterSpec for Reg53Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg53::R`](R) reader structure"] impl crate :: Readable for Reg53Spec { }
#[doc = "`write(|w| ..)` method takes [`reg53::W`](W) writer structure"] impl crate :: Writable for Reg53Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG53 to value 0"] impl crate :: Resettable for Reg53Spec { } }
#[doc = "REG54 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg54::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg54::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg54`] module"]
#[doc (alias = "REG54")] pub type Reg54 = crate :: Reg < reg54 :: Reg54Spec > ;
#[doc = "User-defined"] pub mod reg54 {
#[doc = "Register `REG54` reader"] pub type R = crate :: R < Reg54Spec > ;
#[doc = "Register `REG54` writer"] pub type W = crate :: W < Reg54Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg54::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg54::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg54Spec ; impl crate :: RegisterSpec for Reg54Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg54::R`](R) reader structure"] impl crate :: Readable for Reg54Spec { }
#[doc = "`write(|w| ..)` method takes [`reg54::W`](W) writer structure"] impl crate :: Writable for Reg54Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG54 to value 0"] impl crate :: Resettable for Reg54Spec { } }
#[doc = "REG55 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg55::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg55::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg55`] module"]
#[doc (alias = "REG55")] pub type Reg55 = crate :: Reg < reg55 :: Reg55Spec > ;
#[doc = "User-defined"] pub mod reg55 {
#[doc = "Register `REG55` reader"] pub type R = crate :: R < Reg55Spec > ;
#[doc = "Register `REG55` writer"] pub type W = crate :: W < Reg55Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg55::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg55::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg55Spec ; impl crate :: RegisterSpec for Reg55Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg55::R`](R) reader structure"] impl crate :: Readable for Reg55Spec { }
#[doc = "`write(|w| ..)` method takes [`reg55::W`](W) writer structure"] impl crate :: Writable for Reg55Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG55 to value 0"] impl crate :: Resettable for Reg55Spec { } }
#[doc = "REG56 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg56::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg56::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg56`] module"]
#[doc (alias = "REG56")] pub type Reg56 = crate :: Reg < reg56 :: Reg56Spec > ;
#[doc = "User-defined"] pub mod reg56 {
#[doc = "Register `REG56` reader"] pub type R = crate :: R < Reg56Spec > ;
#[doc = "Register `REG56` writer"] pub type W = crate :: W < Reg56Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg56::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg56::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg56Spec ; impl crate :: RegisterSpec for Reg56Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg56::R`](R) reader structure"] impl crate :: Readable for Reg56Spec { }
#[doc = "`write(|w| ..)` method takes [`reg56::W`](W) writer structure"] impl crate :: Writable for Reg56Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG56 to value 0"] impl crate :: Resettable for Reg56Spec { } }
#[doc = "REG57 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg57::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg57::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg57`] module"]
#[doc (alias = "REG57")] pub type Reg57 = crate :: Reg < reg57 :: Reg57Spec > ;
#[doc = "User-defined"] pub mod reg57 {
#[doc = "Register `REG57` reader"] pub type R = crate :: R < Reg57Spec > ;
#[doc = "Register `REG57` writer"] pub type W = crate :: W < Reg57Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg57::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg57::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg57Spec ; impl crate :: RegisterSpec for Reg57Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg57::R`](R) reader structure"] impl crate :: Readable for Reg57Spec { }
#[doc = "`write(|w| ..)` method takes [`reg57::W`](W) writer structure"] impl crate :: Writable for Reg57Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG57 to value 0"] impl crate :: Resettable for Reg57Spec { } }
#[doc = "REG58 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg58::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg58::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg58`] module"]
#[doc (alias = "REG58")] pub type Reg58 = crate :: Reg < reg58 :: Reg58Spec > ;
#[doc = "User-defined"] pub mod reg58 {
#[doc = "Register `REG58` reader"] pub type R = crate :: R < Reg58Spec > ;
#[doc = "Register `REG58` writer"] pub type W = crate :: W < Reg58Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg58::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg58::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg58Spec ; impl crate :: RegisterSpec for Reg58Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg58::R`](R) reader structure"] impl crate :: Readable for Reg58Spec { }
#[doc = "`write(|w| ..)` method takes [`reg58::W`](W) writer structure"] impl crate :: Writable for Reg58Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG58 to value 0"] impl crate :: Resettable for Reg58Spec { } }
#[doc = "REG59 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg59::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg59::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg59`] module"]
#[doc (alias = "REG59")] pub type Reg59 = crate :: Reg < reg59 :: Reg59Spec > ;
#[doc = "User-defined"] pub mod reg59 {
#[doc = "Register `REG59` reader"] pub type R = crate :: R < Reg59Spec > ;
#[doc = "Register `REG59` writer"] pub type W = crate :: W < Reg59Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg59::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg59::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg59Spec ; impl crate :: RegisterSpec for Reg59Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg59::R`](R) reader structure"] impl crate :: Readable for Reg59Spec { }
#[doc = "`write(|w| ..)` method takes [`reg59::W`](W) writer structure"] impl crate :: Writable for Reg59Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG59 to value 0"] impl crate :: Resettable for Reg59Spec { } }
#[doc = "REG60 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg60::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg60::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg60`] module"]
#[doc (alias = "REG60")] pub type Reg60 = crate :: Reg < reg60 :: Reg60Spec > ;
#[doc = "User-defined"] pub mod reg60 {
#[doc = "Register `REG60` reader"] pub type R = crate :: R < Reg60Spec > ;
#[doc = "Register `REG60` writer"] pub type W = crate :: W < Reg60Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg60::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg60::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg60Spec ; impl crate :: RegisterSpec for Reg60Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg60::R`](R) reader structure"] impl crate :: Readable for Reg60Spec { }
#[doc = "`write(|w| ..)` method takes [`reg60::W`](W) writer structure"] impl crate :: Writable for Reg60Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG60 to value 0"] impl crate :: Resettable for Reg60Spec { } }
#[doc = "REG61 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg61::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg61::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg61`] module"]
#[doc (alias = "REG61")] pub type Reg61 = crate :: Reg < reg61 :: Reg61Spec > ;
#[doc = "User-defined"] pub mod reg61 {
#[doc = "Register `REG61` reader"] pub type R = crate :: R < Reg61Spec > ;
#[doc = "Register `REG61` writer"] pub type W = crate :: W < Reg61Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg61::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg61::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg61Spec ; impl crate :: RegisterSpec for Reg61Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg61::R`](R) reader structure"] impl crate :: Readable for Reg61Spec { }
#[doc = "`write(|w| ..)` method takes [`reg61::W`](W) writer structure"] impl crate :: Writable for Reg61Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG61 to value 0"] impl crate :: Resettable for Reg61Spec { } }
#[doc = "REG62 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg62::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg62::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg62`] module"]
#[doc (alias = "REG62")] pub type Reg62 = crate :: Reg < reg62 :: Reg62Spec > ;
#[doc = "User-defined"] pub mod reg62 {
#[doc = "Register `REG62` reader"] pub type R = crate :: R < Reg62Spec > ;
#[doc = "Register `REG62` writer"] pub type W = crate :: W < Reg62Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg62::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg62::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg62Spec ; impl crate :: RegisterSpec for Reg62Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg62::R`](R) reader structure"] impl crate :: Readable for Reg62Spec { }
#[doc = "`write(|w| ..)` method takes [`reg62::W`](W) writer structure"] impl crate :: Writable for Reg62Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG62 to value 0"] impl crate :: Resettable for Reg62Spec { } }
#[doc = "REG63 (rw) register accessor: User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg63::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg63::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reg63`] module"]
#[doc (alias = "REG63")] pub type Reg63 = crate :: Reg < reg63 :: Reg63Spec > ;
#[doc = "User-defined"] pub mod reg63 {
#[doc = "Register `REG63` reader"] pub type R = crate :: R < Reg63Spec > ;
#[doc = "Register `REG63` writer"] pub type W = crate :: W < Reg63Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "User-defined\n\nYou can [`read`](crate::Reg::read) this register and get [`reg63::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reg63::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Reg63Spec ; impl crate :: RegisterSpec for Reg63Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reg63::R`](R) reader structure"] impl crate :: Readable for Reg63Spec { }
#[doc = "`write(|w| ..)` method takes [`reg63::W`](W) writer structure"] impl crate :: Writable for Reg63Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets REG63 to value 0"] impl crate :: Resettable for Reg63Spec { } } }
#[doc = "Serial data interface controller"] pub type Sdi = crate :: Periph < sdi :: RegisterBlock , 0xfff7_0000 > ; impl core :: fmt :: Debug for Sdi { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Sdi") . finish () } }
#[doc = "Serial data interface controller"] pub mod sdi {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { ctrl : Ctrl , data : Data , } impl RegisterBlock {
#[doc = "0x00 - Control register"]
#[inline (always)] pub const fn ctrl (& self) -> & Ctrl { & self . ctrl }
#[doc = "0x04 - RX/TX data register (lowest 8 bit)"]
#[inline (always)] pub const fn data (& self) -> & Data { & self . data } }
#[doc = "CTRL (rw) register accessor: Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl`] module"]
#[doc (alias = "CTRL")] pub type Ctrl = crate :: Reg < ctrl :: CtrlSpec > ;
#[doc = "Control register"] pub mod ctrl {
#[doc = "Register `CTRL` reader"] pub type R = crate :: R < CtrlSpec > ;
#[doc = "Register `CTRL` writer"] pub type W = crate :: W < CtrlSpec > ;
#[doc = "Field `SDI_CTRL_EN` reader - SDI enable"] pub type SdiCtrlEnR = crate :: BitReader ;
#[doc = "Field `SDI_CTRL_EN` writer - SDI enable"] pub type SdiCtrlEnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SDI_CTRL_CLR_RX` reader - Clear RX FIFO, flag auto-clears"] pub type SdiCtrlClrRxR = crate :: BitReader ;
#[doc = "Field `SDI_CTRL_CLR_RX` writer - Clear RX FIFO, flag auto-clears"] pub type SdiCtrlClrRxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SDI_CTRL_CLR_TX` reader - Clear TX FIFO, flag auto-clears"] pub type SdiCtrlClrTxR = crate :: BitReader ;
#[doc = "Field `SDI_CTRL_CLR_TX` writer - Clear TX FIFO, flag auto-clears"] pub type SdiCtrlClrTxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SDI_CTRL_FIFO` reader - log2(FIFO size)"] pub type SdiCtrlFifoR = crate :: FieldReader ;
#[doc = "Field `SDI_CTRL_FIFO` writer - log2(FIFO size)"] pub type SdiCtrlFifoW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `SDI_CTRL_IRQ_RX_NEMPTY` reader - Fire interrupt if RX FIFO is not empty"] pub type SdiCtrlIrqRxNemptyR = crate :: BitReader ;
#[doc = "Field `SDI_CTRL_IRQ_RX_NEMPTY` writer - Fire interrupt if RX FIFO is not empty"] pub type SdiCtrlIrqRxNemptyW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SDI_CTRL_IRQ_RX_FULL` reader - Fire interrupt if RX FIFO is full"] pub type SdiCtrlIrqRxFullR = crate :: BitReader ;
#[doc = "Field `SDI_CTRL_IRQ_RX_FULL` writer - Fire interrupt if RX FIFO is full"] pub type SdiCtrlIrqRxFullW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SDI_CTRL_IRQ_TX_EMPTY` reader - Fire interrupt if TX FIFO is empty"] pub type SdiCtrlIrqTxEmptyR = crate :: BitReader ;
#[doc = "Field `SDI_CTRL_IRQ_TX_EMPTY` writer - Fire interrupt if TX FIFO is empty"] pub type SdiCtrlIrqTxEmptyW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SDI_CTRL_RX_EMPTY` reader - RX FIFO empty"] pub type SdiCtrlRxEmptyR = crate :: BitReader ;
#[doc = "Field `SDI_CTRL_RX_FULL` reader - RX FIFO full"] pub type SdiCtrlRxFullR = crate :: BitReader ;
#[doc = "Field `SDI_CTRL_TX_EMPTY` reader - TX FIFO empty"] pub type SdiCtrlTxEmptyR = crate :: BitReader ;
#[doc = "Field `SDI_CTRL_TX_FULL` reader - TX FIFO full"] pub type SdiCtrlTxFullR = crate :: BitReader ;
#[doc = "Field `SDI_CTRL_CS_ACTIVE` reader - Chip-select line is active when set"] pub type SdiCtrlCsActiveR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - SDI enable"]
#[inline (always)] pub fn sdi_ctrl_en (& self) -> SdiCtrlEnR { SdiCtrlEnR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Clear RX FIFO, flag auto-clears"]
#[inline (always)] pub fn sdi_ctrl_clr_rx (& self) -> SdiCtrlClrRxR { SdiCtrlClrRxR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Clear TX FIFO, flag auto-clears"]
#[inline (always)] pub fn sdi_ctrl_clr_tx (& self) -> SdiCtrlClrTxR { SdiCtrlClrTxR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bits 4:7 - log2(FIFO size)"]
#[inline (always)] pub fn sdi_ctrl_fifo (& self) -> SdiCtrlFifoR { SdiCtrlFifoR :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bit 16 - Fire interrupt if RX FIFO is not empty"]
#[inline (always)] pub fn sdi_ctrl_irq_rx_nempty (& self) -> SdiCtrlIrqRxNemptyR { SdiCtrlIrqRxNemptyR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Fire interrupt if RX FIFO is full"]
#[inline (always)] pub fn sdi_ctrl_irq_rx_full (& self) -> SdiCtrlIrqRxFullR { SdiCtrlIrqRxFullR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Fire interrupt if TX FIFO is empty"]
#[inline (always)] pub fn sdi_ctrl_irq_tx_empty (& self) -> SdiCtrlIrqTxEmptyR { SdiCtrlIrqTxEmptyR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 24 - RX FIFO empty"]
#[inline (always)] pub fn sdi_ctrl_rx_empty (& self) -> SdiCtrlRxEmptyR { SdiCtrlRxEmptyR :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - RX FIFO full"]
#[inline (always)] pub fn sdi_ctrl_rx_full (& self) -> SdiCtrlRxFullR { SdiCtrlRxFullR :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - TX FIFO empty"]
#[inline (always)] pub fn sdi_ctrl_tx_empty (& self) -> SdiCtrlTxEmptyR { SdiCtrlTxEmptyR :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 28 - TX FIFO full"]
#[inline (always)] pub fn sdi_ctrl_tx_full (& self) -> SdiCtrlTxFullR { SdiCtrlTxFullR :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 31 - Chip-select line is active when set"]
#[inline (always)] pub fn sdi_ctrl_cs_active (& self) -> SdiCtrlCsActiveR { SdiCtrlCsActiveR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - SDI enable"]
#[inline (always)] pub fn sdi_ctrl_en (& mut self) -> SdiCtrlEnW < '_ , CtrlSpec > { SdiCtrlEnW :: new (self , 0) }
#[doc = "Bit 1 - Clear RX FIFO, flag auto-clears"]
#[inline (always)] pub fn sdi_ctrl_clr_rx (& mut self) -> SdiCtrlClrRxW < '_ , CtrlSpec > { SdiCtrlClrRxW :: new (self , 1) }
#[doc = "Bit 2 - Clear TX FIFO, flag auto-clears"]
#[inline (always)] pub fn sdi_ctrl_clr_tx (& mut self) -> SdiCtrlClrTxW < '_ , CtrlSpec > { SdiCtrlClrTxW :: new (self , 2) }
#[doc = "Bits 4:7 - log2(FIFO size)"]
#[inline (always)] pub fn sdi_ctrl_fifo (& mut self) -> SdiCtrlFifoW < '_ , CtrlSpec > { SdiCtrlFifoW :: new (self , 4) }
#[doc = "Bit 16 - Fire interrupt if RX FIFO is not empty"]
#[inline (always)] pub fn sdi_ctrl_irq_rx_nempty (& mut self) -> SdiCtrlIrqRxNemptyW < '_ , CtrlSpec > { SdiCtrlIrqRxNemptyW :: new (self , 16) }
#[doc = "Bit 17 - Fire interrupt if RX FIFO is full"]
#[inline (always)] pub fn sdi_ctrl_irq_rx_full (& mut self) -> SdiCtrlIrqRxFullW < '_ , CtrlSpec > { SdiCtrlIrqRxFullW :: new (self , 17) }
#[doc = "Bit 18 - Fire interrupt if TX FIFO is empty"]
#[inline (always)] pub fn sdi_ctrl_irq_tx_empty (& mut self) -> SdiCtrlIrqTxEmptyW < '_ , CtrlSpec > { SdiCtrlIrqTxEmptyW :: new (self , 18) } }
#[doc = "Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CtrlSpec ; impl crate :: RegisterSpec for CtrlSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ctrl::R`](R) reader structure"] impl crate :: Readable for CtrlSpec { }
#[doc = "`write(|w| ..)` method takes [`ctrl::W`](W) writer structure"] impl crate :: Writable for CtrlSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CTRL to value 0"] impl crate :: Resettable for CtrlSpec { } }
#[doc = "DATA (rw) register accessor: RX/TX data register (lowest 8 bit)\n\nYou can [`read`](crate::Reg::read) this register and get [`data::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`data::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\n<div class=\"warning\">The register is <b>modified</b> in some way after a read operation.</div>\n\nFor information about available fields see [`mod@data`] module"]
#[doc (alias = "DATA")] pub type Data = crate :: Reg < data :: DataSpec > ;
#[doc = "RX/TX data register (lowest 8 bit)"] pub mod data {
#[doc = "Register `DATA` reader"] pub type R = crate :: R < DataSpec > ;
#[doc = "Register `DATA` writer"] pub type W = crate :: W < DataSpec > ; impl core :: fmt :: Debug for crate :: generic :: Reg < DataSpec > { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { write ! (f , "(not readable)") } } impl W { }
#[doc = "RX/TX data register (lowest 8 bit)\n\nYou can [`read`](crate::Reg::read) this register and get [`data::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`data::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\n<div class=\"warning\">The register is <b>modified</b> in some way after a read operation.</div>"] pub struct DataSpec ; impl crate :: RegisterSpec for DataSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`data::R`](R) reader structure"] impl crate :: Readable for DataSpec { }
#[doc = "`write(|w| ..)` method takes [`data::W`](W) writer structure"] impl crate :: Writable for DataSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DATA to value 0"] impl crate :: Resettable for DataSpec { } } }
#[doc = "Stream Link Interface"] pub type Slink = crate :: Periph < slink :: RegisterBlock , 0xffec_0000 > ; impl core :: fmt :: Debug for Slink { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Slink") . finish () } }
#[doc = "Stream Link Interface"] pub mod slink {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { ctrl : Ctrl , route : Route , data : Data , data_last : DataLast , } impl RegisterBlock {
#[doc = "0x00 - Control register"]
#[inline (always)] pub const fn ctrl (& self) -> & Ctrl { & self . ctrl }
#[doc = "0x04 - Routing information"]
#[inline (always)] pub const fn route (& self) -> & Route { & self . route }
#[doc = "0x08 - RX/TX data register"]
#[inline (always)] pub const fn data (& self) -> & Data { & self . data }
#[doc = "0x0c - TX data register (plus TX end-of-stream delimiter)"]
#[inline (always)] pub const fn data_last (& self) -> & DataLast { & self . data_last } }
#[doc = "CTRL (rw) register accessor: Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl`] module"]
#[doc (alias = "CTRL")] pub type Ctrl = crate :: Reg < ctrl :: CtrlSpec > ;
#[doc = "Control register"] pub mod ctrl {
#[doc = "Register `CTRL` reader"] pub type R = crate :: R < CtrlSpec > ;
#[doc = "Register `CTRL` writer"] pub type W = crate :: W < CtrlSpec > ;
#[doc = "Field `SLINK_CTRL_EN` reader - SLINK enable flag"] pub type SlinkCtrlEnR = crate :: BitReader ;
#[doc = "Field `SLINK_CTRL_EN` writer - SLINK enable flag"] pub type SlinkCtrlEnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SLINK_CTRL_RX_EMPTY` reader - RX FIFO empty"] pub type SlinkCtrlRxEmptyR = crate :: BitReader ;
#[doc = "Field `SLINK_CTRL_RX_FULL` reader - RX FIFO full"] pub type SlinkCtrlRxFullR = crate :: BitReader ;
#[doc = "Field `SLINK_CTRL_TX_EMPTY` reader - TX FIFO empty"] pub type SlinkCtrlTxEmptyR = crate :: BitReader ;
#[doc = "Field `SLINK_CTRL_TX_FULL` reader - TX FIFO full"] pub type SlinkCtrlTxFullR = crate :: BitReader ;
#[doc = "Field `SLINK_CTRL_RX_LAST` reader - RX link end-of-stream delimiter"] pub type SlinkCtrlRxLastR = crate :: BitReader ;
#[doc = "Field `SLINK_CTRL_RX_LAST` writer - RX link end-of-stream delimiter"] pub type SlinkCtrlRxLastW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SLINK_CTRL_IRQ_RX_NEMPTY` reader - Interrupt if RX FIFO not empty"] pub type SlinkCtrlIrqRxNemptyR = crate :: BitReader ;
#[doc = "Field `SLINK_CTRL_IRQ_RX_NEMPTY` writer - Interrupt if RX FIFO not empty"] pub type SlinkCtrlIrqRxNemptyW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SLINK_CTRL_IRQ_RX_FULL` reader - Interrupt if RX FIFO full"] pub type SlinkCtrlIrqRxFullR = crate :: BitReader ;
#[doc = "Field `SLINK_CTRL_IRQ_RX_FULL` writer - Interrupt if RX FIFO full"] pub type SlinkCtrlIrqRxFullW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SLINK_CTRL_IRQ_TX_EMPTY` reader - Interrupt if TX FIFO empty"] pub type SlinkCtrlIrqTxEmptyR = crate :: BitReader ;
#[doc = "Field `SLINK_CTRL_IRQ_TX_EMPTY` writer - Interrupt if TX FIFO empty"] pub type SlinkCtrlIrqTxEmptyW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SLINK_CTRL_IRQ_TX_NFULL` reader - Interrupt if TX FIFO not full"] pub type SlinkCtrlIrqTxNfullR = crate :: BitReader ;
#[doc = "Field `SLINK_CTRL_IRQ_TX_NFULL` writer - Interrupt if TX FIFO not full"] pub type SlinkCtrlIrqTxNfullW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SLINK_CTRL_RX_FIFO` reader - log2(RX FIFO size)"] pub type SlinkCtrlRxFifoR = crate :: FieldReader ;
#[doc = "Field `SLINK_CTRL_TX_FIFO` reader - log2(TX FIFO size)"] pub type SlinkCtrlTxFifoR = crate :: FieldReader ; impl R {
#[doc = "Bit 0 - SLINK enable flag"]
#[inline (always)] pub fn slink_ctrl_en (& self) -> SlinkCtrlEnR { SlinkCtrlEnR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 8 - RX FIFO empty"]
#[inline (always)] pub fn slink_ctrl_rx_empty (& self) -> SlinkCtrlRxEmptyR { SlinkCtrlRxEmptyR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - RX FIFO full"]
#[inline (always)] pub fn slink_ctrl_rx_full (& self) -> SlinkCtrlRxFullR { SlinkCtrlRxFullR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - TX FIFO empty"]
#[inline (always)] pub fn slink_ctrl_tx_empty (& self) -> SlinkCtrlTxEmptyR { SlinkCtrlTxEmptyR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - TX FIFO full"]
#[inline (always)] pub fn slink_ctrl_tx_full (& self) -> SlinkCtrlTxFullR { SlinkCtrlTxFullR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - RX link end-of-stream delimiter"]
#[inline (always)] pub fn slink_ctrl_rx_last (& self) -> SlinkCtrlRxLastR { SlinkCtrlRxLastR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 16 - Interrupt if RX FIFO not empty"]
#[inline (always)] pub fn slink_ctrl_irq_rx_nempty (& self) -> SlinkCtrlIrqRxNemptyR { SlinkCtrlIrqRxNemptyR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Interrupt if RX FIFO full"]
#[inline (always)] pub fn slink_ctrl_irq_rx_full (& self) -> SlinkCtrlIrqRxFullR { SlinkCtrlIrqRxFullR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Interrupt if TX FIFO empty"]
#[inline (always)] pub fn slink_ctrl_irq_tx_empty (& self) -> SlinkCtrlIrqTxEmptyR { SlinkCtrlIrqTxEmptyR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Interrupt if TX FIFO not full"]
#[inline (always)] pub fn slink_ctrl_irq_tx_nfull (& self) -> SlinkCtrlIrqTxNfullR { SlinkCtrlIrqTxNfullR :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bits 24:27 - log2(RX FIFO size)"]
#[inline (always)] pub fn slink_ctrl_rx_fifo (& self) -> SlinkCtrlRxFifoR { SlinkCtrlRxFifoR :: new (((self . bits >> 24) & 0x0f) as u8) }
#[doc = "Bits 28:31 - log2(TX FIFO size)"]
#[inline (always)] pub fn slink_ctrl_tx_fifo (& self) -> SlinkCtrlTxFifoR { SlinkCtrlTxFifoR :: new (((self . bits >> 28) & 0x0f) as u8) } } impl W {
#[doc = "Bit 0 - SLINK enable flag"]
#[inline (always)] pub fn slink_ctrl_en (& mut self) -> SlinkCtrlEnW < '_ , CtrlSpec > { SlinkCtrlEnW :: new (self , 0) }
#[doc = "Bit 12 - RX link end-of-stream delimiter"]
#[inline (always)] pub fn slink_ctrl_rx_last (& mut self) -> SlinkCtrlRxLastW < '_ , CtrlSpec > { SlinkCtrlRxLastW :: new (self , 12) }
#[doc = "Bit 16 - Interrupt if RX FIFO not empty"]
#[inline (always)] pub fn slink_ctrl_irq_rx_nempty (& mut self) -> SlinkCtrlIrqRxNemptyW < '_ , CtrlSpec > { SlinkCtrlIrqRxNemptyW :: new (self , 16) }
#[doc = "Bit 17 - Interrupt if RX FIFO full"]
#[inline (always)] pub fn slink_ctrl_irq_rx_full (& mut self) -> SlinkCtrlIrqRxFullW < '_ , CtrlSpec > { SlinkCtrlIrqRxFullW :: new (self , 17) }
#[doc = "Bit 18 - Interrupt if TX FIFO empty"]
#[inline (always)] pub fn slink_ctrl_irq_tx_empty (& mut self) -> SlinkCtrlIrqTxEmptyW < '_ , CtrlSpec > { SlinkCtrlIrqTxEmptyW :: new (self , 18) }
#[doc = "Bit 19 - Interrupt if TX FIFO not full"]
#[inline (always)] pub fn slink_ctrl_irq_tx_nfull (& mut self) -> SlinkCtrlIrqTxNfullW < '_ , CtrlSpec > { SlinkCtrlIrqTxNfullW :: new (self , 19) } }
#[doc = "Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CtrlSpec ; impl crate :: RegisterSpec for CtrlSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ctrl::R`](R) reader structure"] impl crate :: Readable for CtrlSpec { }
#[doc = "`write(|w| ..)` method takes [`ctrl::W`](W) writer structure"] impl crate :: Writable for CtrlSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CTRL to value 0"] impl crate :: Resettable for CtrlSpec { } }
#[doc = "ROUTE (rw) register accessor: Routing information\n\nYou can [`read`](crate::Reg::read) this register and get [`route::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`route::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@route`] module"]
#[doc (alias = "ROUTE")] pub type Route = crate :: Reg < route :: RouteSpec > ;
#[doc = "Routing information"] pub mod route {
#[doc = "Register `ROUTE` reader"] pub type R = crate :: R < RouteSpec > ;
#[doc = "Register `ROUTE` writer"] pub type W = crate :: W < RouteSpec > ;
#[doc = "Field `SLINK_ROUTE` reader - RX/TX stream source/destination address/ID"] pub type SlinkRouteR = crate :: FieldReader ;
#[doc = "Field `SLINK_ROUTE` writer - RX/TX stream source/destination address/ID"] pub type SlinkRouteW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:3 - RX/TX stream source/destination address/ID"]
#[inline (always)] pub fn slink_route (& self) -> SlinkRouteR { SlinkRouteR :: new ((self . bits & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:3 - RX/TX stream source/destination address/ID"]
#[inline (always)] pub fn slink_route (& mut self) -> SlinkRouteW < '_ , RouteSpec > { SlinkRouteW :: new (self , 0) } }
#[doc = "Routing information\n\nYou can [`read`](crate::Reg::read) this register and get [`route::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`route::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RouteSpec ; impl crate :: RegisterSpec for RouteSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`route::R`](R) reader structure"] impl crate :: Readable for RouteSpec { }
#[doc = "`write(|w| ..)` method takes [`route::W`](W) writer structure"] impl crate :: Writable for RouteSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ROUTE to value 0"] impl crate :: Resettable for RouteSpec { } }
#[doc = "DATA (rw) register accessor: RX/TX data register\n\nYou can [`read`](crate::Reg::read) this register and get [`data::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`data::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\n<div class=\"warning\">The register is <b>modified</b> in some way after a read operation.</div>\n\nFor information about available fields see [`mod@data`] module"]
#[doc (alias = "DATA")] pub type Data = crate :: Reg < data :: DataSpec > ;
#[doc = "RX/TX data register"] pub mod data {
#[doc = "Register `DATA` reader"] pub type R = crate :: R < DataSpec > ;
#[doc = "Register `DATA` writer"] pub type W = crate :: W < DataSpec > ; impl core :: fmt :: Debug for crate :: generic :: Reg < DataSpec > { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { write ! (f , "(not readable)") } } impl W { }
#[doc = "RX/TX data register\n\nYou can [`read`](crate::Reg::read) this register and get [`data::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`data::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\n<div class=\"warning\">The register is <b>modified</b> in some way after a read operation.</div>"] pub struct DataSpec ; impl crate :: RegisterSpec for DataSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`data::R`](R) reader structure"] impl crate :: Readable for DataSpec { }
#[doc = "`write(|w| ..)` method takes [`data::W`](W) writer structure"] impl crate :: Writable for DataSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DATA to value 0"] impl crate :: Resettable for DataSpec { } }
#[doc = "DATA_LAST (rw) register accessor: TX data register (plus TX end-of-stream delimiter)\n\nYou can [`read`](crate::Reg::read) this register and get [`data_last::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`data_last::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\n<div class=\"warning\">The register is <b>modified</b> in some way after a read operation.</div>\n\nFor information about available fields see [`mod@data_last`] module"]
#[doc (alias = "DATA_LAST")] pub type DataLast = crate :: Reg < data_last :: DataLastSpec > ;
#[doc = "TX data register (plus TX end-of-stream delimiter)"] pub mod data_last {
#[doc = "Register `DATA_LAST` reader"] pub type R = crate :: R < DataLastSpec > ;
#[doc = "Register `DATA_LAST` writer"] pub type W = crate :: W < DataLastSpec > ; impl core :: fmt :: Debug for crate :: generic :: Reg < DataLastSpec > { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { write ! (f , "(not readable)") } } impl W { }
#[doc = "TX data register (plus TX end-of-stream delimiter)\n\nYou can [`read`](crate::Reg::read) this register and get [`data_last::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`data_last::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\n<div class=\"warning\">The register is <b>modified</b> in some way after a read operation.</div>"] pub struct DataLastSpec ; impl crate :: RegisterSpec for DataLastSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`data_last::R`](R) reader structure"] impl crate :: Readable for DataLastSpec { }
#[doc = "`write(|w| ..)` method takes [`data_last::W`](W) writer structure"] impl crate :: Writable for DataLastSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DATA_LAST to value 0"] impl crate :: Resettable for DataLastSpec { } } }
#[doc = "Direct memory access controller"] pub type Dma = crate :: Periph < dma :: RegisterBlock , 0xffed_0000 > ; impl core :: fmt :: Debug for Dma { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dma") . finish () } }
#[doc = "Direct memory access controller"] pub mod dma {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { ctrl : Ctrl , desc : Desc , } impl RegisterBlock {
#[doc = "0x00 - Control and status register"]
#[inline (always)] pub const fn ctrl (& self) -> & Ctrl { & self . ctrl }
#[doc = "0x04 - Descriptor FIFO"]
#[inline (always)] pub const fn desc (& self) -> & Desc { & self . desc } }
#[doc = "CTRL (rw) register accessor: Control and status register\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl`] module"]
#[doc (alias = "CTRL")] pub type Ctrl = crate :: Reg < ctrl :: CtrlSpec > ;
#[doc = "Control and status register"] pub mod ctrl {
#[doc = "Register `CTRL` reader"] pub type R = crate :: R < CtrlSpec > ;
#[doc = "Register `CTRL` writer"] pub type W = crate :: W < CtrlSpec > ;
#[doc = "Field `DMA_CTRL_EN` reader - DMA enable flag"] pub type DmaCtrlEnR = crate :: BitReader ;
#[doc = "Field `DMA_CTRL_EN` writer - DMA enable flag"] pub type DmaCtrlEnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMA_CTRL_START` writer - Start programmed DMA transfer(s)"] pub type DmaCtrlStartW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMA_CTRL_FIFO` reader - log2(descriptor FIFO depth)"] pub type DmaCtrlFifoR = crate :: FieldReader ;
#[doc = "Field `DMA_CTRL_ACK` writer - Write 1 to clear ERROR and DONE flags"] pub type DmaCtrlAckW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMA_CTRL_DEMPTY` reader - Descriptor FIFO is empty"] pub type DmaCtrlDemptyR = crate :: BitReader ;
#[doc = "Field `DMA_CTRL_DFULL` reader - Descriptor FIFO is full"] pub type DmaCtrlDfullR = crate :: BitReader ;
#[doc = "Field `DMA_CTRL_ERROR` reader - Error during last transfer"] pub type DmaCtrlErrorR = crate :: BitReader ;
#[doc = "Field `DMA_CTRL_DONE` reader - Transfer(s) done"] pub type DmaCtrlDoneR = crate :: BitReader ;
#[doc = "Field `DMA_CTRL_BUSY` reader - Transfer(s) in progress"] pub type DmaCtrlBusyR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - DMA enable flag"]
#[inline (always)] pub fn dma_ctrl_en (& self) -> DmaCtrlEnR { DmaCtrlEnR :: new ((self . bits & 1) != 0) }
#[doc = "Bits 16:19 - log2(descriptor FIFO depth)"]
#[inline (always)] pub fn dma_ctrl_fifo (& self) -> DmaCtrlFifoR { DmaCtrlFifoR :: new (((self . bits >> 16) & 0x0f) as u8) }
#[doc = "Bit 27 - Descriptor FIFO is empty"]
#[inline (always)] pub fn dma_ctrl_dempty (& self) -> DmaCtrlDemptyR { DmaCtrlDemptyR :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - Descriptor FIFO is full"]
#[inline (always)] pub fn dma_ctrl_dfull (& self) -> DmaCtrlDfullR { DmaCtrlDfullR :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - Error during last transfer"]
#[inline (always)] pub fn dma_ctrl_error (& self) -> DmaCtrlErrorR { DmaCtrlErrorR :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Transfer(s) done"]
#[inline (always)] pub fn dma_ctrl_done (& self) -> DmaCtrlDoneR { DmaCtrlDoneR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Transfer(s) in progress"]
#[inline (always)] pub fn dma_ctrl_busy (& self) -> DmaCtrlBusyR { DmaCtrlBusyR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - DMA enable flag"]
#[inline (always)] pub fn dma_ctrl_en (& mut self) -> DmaCtrlEnW < '_ , CtrlSpec > { DmaCtrlEnW :: new (self , 0) }
#[doc = "Bit 1 - Start programmed DMA transfer(s)"]
#[inline (always)] pub fn dma_ctrl_start (& mut self) -> DmaCtrlStartW < '_ , CtrlSpec > { DmaCtrlStartW :: new (self , 1) }
#[doc = "Bit 26 - Write 1 to clear ERROR and DONE flags"]
#[inline (always)] pub fn dma_ctrl_ack (& mut self) -> DmaCtrlAckW < '_ , CtrlSpec > { DmaCtrlAckW :: new (self , 26) } }
#[doc = "Control and status register\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CtrlSpec ; impl crate :: RegisterSpec for CtrlSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ctrl::R`](R) reader structure"] impl crate :: Readable for CtrlSpec { }
#[doc = "`write(|w| ..)` method takes [`ctrl::W`](W) writer structure"] impl crate :: Writable for CtrlSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CTRL to value 0"] impl crate :: Resettable for CtrlSpec { } }
#[doc = "DESC (w) register accessor: Descriptor FIFO\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`desc::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@desc`] module"]
#[doc (alias = "DESC")] pub type Desc = crate :: Reg < desc :: DescSpec > ;
#[doc = "Descriptor FIFO"] pub mod desc {
#[doc = "Register `DESC` writer"] pub type W = crate :: W < DescSpec > ; impl core :: fmt :: Debug for crate :: generic :: Reg < DescSpec > { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { write ! (f , "(not readable)") } } impl W { }
#[doc = "Descriptor FIFO\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`desc::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DescSpec ; impl crate :: RegisterSpec for DescSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`desc::W`](W) writer structure"] impl crate :: Writable for DescSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DESC to value 0"] impl crate :: Resettable for DescSpec { } } }
#[doc = "Pulse-width modulation controller"] pub type Pwm = crate :: Periph < pwm :: RegisterBlock , 0xfff0_0000 > ; impl core :: fmt :: Debug for Pwm { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Pwm") . finish () } }
#[doc = "Pulse-width modulation controller"] pub mod pwm {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { channel_cfg0 : ChannelCfg0 , channel_cfg1 : ChannelCfg1 , channel_cfg2 : ChannelCfg2 , channel_cfg3 : ChannelCfg3 , channel_cfg4 : ChannelCfg4 , channel_cfg5 : ChannelCfg5 , channel_cfg6 : ChannelCfg6 , channel_cfg7 : ChannelCfg7 , channel_cfg8 : ChannelCfg8 , channel_cfg9 : ChannelCfg9 , channel_cfg10 : ChannelCfg10 , channel_cfg11 : ChannelCfg11 , channel_cfg12 : ChannelCfg12 , channel_cfg13 : ChannelCfg13 , channel_cfg14 : ChannelCfg14 , channel_cfg15 : ChannelCfg15 , } impl RegisterBlock {
#[doc = "0x00 - Channel 0 configuration register"]
#[inline (always)] pub const fn channel_cfg0 (& self) -> & ChannelCfg0 { & self . channel_cfg0 }
#[doc = "0x04 - Channel 1 configuration register"]
#[inline (always)] pub const fn channel_cfg1 (& self) -> & ChannelCfg1 { & self . channel_cfg1 }
#[doc = "0x08 - Channel 2 configuration register"]
#[inline (always)] pub const fn channel_cfg2 (& self) -> & ChannelCfg2 { & self . channel_cfg2 }
#[doc = "0x0c - Channel 3 configuration register"]
#[inline (always)] pub const fn channel_cfg3 (& self) -> & ChannelCfg3 { & self . channel_cfg3 }
#[doc = "0x10 - Channel 4 configuration register"]
#[inline (always)] pub const fn channel_cfg4 (& self) -> & ChannelCfg4 { & self . channel_cfg4 }
#[doc = "0x14 - Channel 5 configuration register"]
#[inline (always)] pub const fn channel_cfg5 (& self) -> & ChannelCfg5 { & self . channel_cfg5 }
#[doc = "0x18 - Channel 6 configuration register"]
#[inline (always)] pub const fn channel_cfg6 (& self) -> & ChannelCfg6 { & self . channel_cfg6 }
#[doc = "0x1c - Channel 7 configuration register"]
#[inline (always)] pub const fn channel_cfg7 (& self) -> & ChannelCfg7 { & self . channel_cfg7 }
#[doc = "0x20 - Channel 8 configuration register"]
#[inline (always)] pub const fn channel_cfg8 (& self) -> & ChannelCfg8 { & self . channel_cfg8 }
#[doc = "0x24 - Channel 9 configuration register"]
#[inline (always)] pub const fn channel_cfg9 (& self) -> & ChannelCfg9 { & self . channel_cfg9 }
#[doc = "0x28 - Channel 10 configuration register"]
#[inline (always)] pub const fn channel_cfg10 (& self) -> & ChannelCfg10 { & self . channel_cfg10 }
#[doc = "0x2c - Channel 11 configuration register"]
#[inline (always)] pub const fn channel_cfg11 (& self) -> & ChannelCfg11 { & self . channel_cfg11 }
#[doc = "0x30 - Channel 12 configuration register"]
#[inline (always)] pub const fn channel_cfg12 (& self) -> & ChannelCfg12 { & self . channel_cfg12 }
#[doc = "0x34 - Channel 13 configuration register"]
#[inline (always)] pub const fn channel_cfg13 (& self) -> & ChannelCfg13 { & self . channel_cfg13 }
#[doc = "0x38 - Channel 14 configuration register"]
#[inline (always)] pub const fn channel_cfg14 (& self) -> & ChannelCfg14 { & self . channel_cfg14 }
#[doc = "0x3c - Channel 15 configuration register"]
#[inline (always)] pub const fn channel_cfg15 (& self) -> & ChannelCfg15 { & self . channel_cfg15 } }
#[doc = "CHANNEL_CFG[0] (rw) register accessor: Channel 0 configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`channel_cfg0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`channel_cfg0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@channel_cfg0`] module"]
#[doc (alias = "CHANNEL_CFG[0]")] pub type ChannelCfg0 = crate :: Reg < channel_cfg0 :: ChannelCfg0Spec > ;
#[doc = "Channel 0 configuration register"] pub mod channel_cfg0 {
#[doc = "Register `CHANNEL_CFG[0]` reader"] pub type R = crate :: R < ChannelCfg0Spec > ;
#[doc = "Register `CHANNEL_CFG[0]` writer"] pub type W = crate :: W < ChannelCfg0Spec > ;
#[doc = "Field `PWM_CFG_DUTY` reader - Duty cycle"] pub type PwmCfgDutyR = crate :: FieldReader ;
#[doc = "Field `PWM_CFG_DUTY` writer - Duty cycle"] pub type PwmCfgDutyW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `PWM_CFG_CDIV` reader - Clock divider"] pub type PwmCfgCdivR = crate :: FieldReader < u16 > ;
#[doc = "Field `PWM_CFG_CDIV` writer - Clock divider"] pub type PwmCfgCdivW < 'a , REG > = crate :: FieldWriter < 'a , REG , 10 , u16 > ;
#[doc = "Field `PWM_CFG_POL` reader - Channel polarity, inverted when set"] pub type PwmCfgPolR = crate :: BitReader ;
#[doc = "Field `PWM_CFG_POL` writer - Channel polarity, inverted when set"] pub type PwmCfgPolW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PWM_CFG_PRSC` reader - Clock prescaler select"] pub type PwmCfgPrscR = crate :: FieldReader ;
#[doc = "Field `PWM_CFG_PRSC` writer - Clock prescaler select"] pub type PwmCfgPrscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `PWM_CFG_EN` reader - Channel enable"] pub type PwmCfgEnR = crate :: BitReader ;
#[doc = "Field `PWM_CFG_EN` writer - Channel enable"] pub type PwmCfgEnW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Duty cycle"]
#[inline (always)] pub fn pwm_cfg_duty (& self) -> PwmCfgDutyR { PwmCfgDutyR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:17 - Clock divider"]
#[inline (always)] pub fn pwm_cfg_cdiv (& self) -> PwmCfgCdivR { PwmCfgCdivR :: new (((self . bits >> 8) & 0x03ff) as u16) }
#[doc = "Bit 27 - Channel polarity, inverted when set"]
#[inline (always)] pub fn pwm_cfg_pol (& self) -> PwmCfgPolR { PwmCfgPolR :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bits 28:30 - Clock prescaler select"]
#[inline (always)] pub fn pwm_cfg_prsc (& self) -> PwmCfgPrscR { PwmCfgPrscR :: new (((self . bits >> 28) & 7) as u8) }
#[doc = "Bit 31 - Channel enable"]
#[inline (always)] pub fn pwm_cfg_en (& self) -> PwmCfgEnR { PwmCfgEnR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Duty cycle"]
#[inline (always)] pub fn pwm_cfg_duty (& mut self) -> PwmCfgDutyW < '_ , ChannelCfg0Spec > { PwmCfgDutyW :: new (self , 0) }
#[doc = "Bits 8:17 - Clock divider"]
#[inline (always)] pub fn pwm_cfg_cdiv (& mut self) -> PwmCfgCdivW < '_ , ChannelCfg0Spec > { PwmCfgCdivW :: new (self , 8) }
#[doc = "Bit 27 - Channel polarity, inverted when set"]
#[inline (always)] pub fn pwm_cfg_pol (& mut self) -> PwmCfgPolW < '_ , ChannelCfg0Spec > { PwmCfgPolW :: new (self , 27) }
#[doc = "Bits 28:30 - Clock prescaler select"]
#[inline (always)] pub fn pwm_cfg_prsc (& mut self) -> PwmCfgPrscW < '_ , ChannelCfg0Spec > { PwmCfgPrscW :: new (self , 28) }
#[doc = "Bit 31 - Channel enable"]
#[inline (always)] pub fn pwm_cfg_en (& mut self) -> PwmCfgEnW < '_ , ChannelCfg0Spec > { PwmCfgEnW :: new (self , 31) } }
#[doc = "Channel 0 configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`channel_cfg0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`channel_cfg0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ChannelCfg0Spec ; impl crate :: RegisterSpec for ChannelCfg0Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`channel_cfg0::R`](R) reader structure"] impl crate :: Readable for ChannelCfg0Spec { }
#[doc = "`write(|w| ..)` method takes [`channel_cfg0::W`](W) writer structure"] impl crate :: Writable for ChannelCfg0Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CHANNEL_CFG[0] to value 0"] impl crate :: Resettable for ChannelCfg0Spec { } } pub use ChannelCfg0 as ChannelCfg1 ; pub use channel_cfg0 as channel_cfg1 ; pub use ChannelCfg0 as ChannelCfg2 ; pub use channel_cfg0 as channel_cfg2 ; pub use ChannelCfg0 as ChannelCfg3 ; pub use channel_cfg0 as channel_cfg3 ; pub use ChannelCfg0 as ChannelCfg4 ; pub use channel_cfg0 as channel_cfg4 ; pub use ChannelCfg0 as ChannelCfg5 ; pub use channel_cfg0 as channel_cfg5 ; pub use ChannelCfg0 as ChannelCfg6 ; pub use channel_cfg0 as channel_cfg6 ; pub use ChannelCfg0 as ChannelCfg7 ; pub use channel_cfg0 as channel_cfg7 ; pub use ChannelCfg0 as ChannelCfg8 ; pub use channel_cfg0 as channel_cfg8 ; pub use ChannelCfg0 as ChannelCfg9 ; pub use channel_cfg0 as channel_cfg9 ; pub use ChannelCfg0 as ChannelCfg10 ; pub use channel_cfg0 as channel_cfg10 ; pub use ChannelCfg0 as ChannelCfg11 ; pub use channel_cfg0 as channel_cfg11 ; pub use ChannelCfg0 as ChannelCfg12 ; pub use channel_cfg0 as channel_cfg12 ; pub use ChannelCfg0 as ChannelCfg13 ; pub use channel_cfg0 as channel_cfg13 ; pub use ChannelCfg0 as ChannelCfg14 ; pub use channel_cfg0 as channel_cfg14 ; pub use ChannelCfg0 as ChannelCfg15 ; pub use channel_cfg0 as channel_cfg15 ; }
#[doc = "General purpose timer"] pub type Gptmr = crate :: Periph < gptmr :: RegisterBlock , 0xfff1_0000 > ; impl core :: fmt :: Debug for Gptmr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gptmr") . finish () } }
#[doc = "General purpose timer"] pub mod gptmr {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { ctrl : Ctrl , thres : Thres , count : Count , } impl RegisterBlock {
#[doc = "0x00 - Control register"]
#[inline (always)] pub const fn ctrl (& self) -> & Ctrl { & self . ctrl }
#[doc = "0x04 - Threshold register"]
#[inline (always)] pub const fn thres (& self) -> & Thres { & self . thres }
#[doc = "0x08 - Counter register"]
#[inline (always)] pub const fn count (& self) -> & Count { & self . count } }
#[doc = "CTRL (rw) register accessor: Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl`] module"]
#[doc (alias = "CTRL")] pub type Ctrl = crate :: Reg < ctrl :: CtrlSpec > ;
#[doc = "Control register"] pub mod ctrl {
#[doc = "Register `CTRL` reader"] pub type R = crate :: R < CtrlSpec > ;
#[doc = "Register `CTRL` writer"] pub type W = crate :: W < CtrlSpec > ;
#[doc = "Field `GPTMR_CTRL_EN` reader - Timer enable flag"] pub type GptmrCtrlEnR = crate :: BitReader ;
#[doc = "Field `GPTMR_CTRL_EN` writer - Timer enable flag"] pub type GptmrCtrlEnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GPTMR_CTRL_PRSC` reader - Clock prescaler select"] pub type GptmrCtrlPrscR = crate :: FieldReader ;
#[doc = "Field `GPTMR_CTRL_PRSC` writer - Clock prescaler select"] pub type GptmrCtrlPrscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `GPTMR_CTRL_IRQ_CLR` writer - Set to clear timer-match interrupt"] pub type GptmrCtrlIrqClrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GPTMR_CTRL_IRQ_PND` reader - Timer-match interrupt pending"] pub type GptmrCtrlIrqPndR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Timer enable flag"]
#[inline (always)] pub fn gptmr_ctrl_en (& self) -> GptmrCtrlEnR { GptmrCtrlEnR :: new ((self . bits & 1) != 0) }
#[doc = "Bits 1:3 - Clock prescaler select"]
#[inline (always)] pub fn gptmr_ctrl_prsc (& self) -> GptmrCtrlPrscR { GptmrCtrlPrscR :: new (((self . bits >> 1) & 7) as u8) }
#[doc = "Bit 31 - Timer-match interrupt pending"]
#[inline (always)] pub fn gptmr_ctrl_irq_pnd (& self) -> GptmrCtrlIrqPndR { GptmrCtrlIrqPndR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Timer enable flag"]
#[inline (always)] pub fn gptmr_ctrl_en (& mut self) -> GptmrCtrlEnW < '_ , CtrlSpec > { GptmrCtrlEnW :: new (self , 0) }
#[doc = "Bits 1:3 - Clock prescaler select"]
#[inline (always)] pub fn gptmr_ctrl_prsc (& mut self) -> GptmrCtrlPrscW < '_ , CtrlSpec > { GptmrCtrlPrscW :: new (self , 1) }
#[doc = "Bit 30 - Set to clear timer-match interrupt"]
#[inline (always)] pub fn gptmr_ctrl_irq_clr (& mut self) -> GptmrCtrlIrqClrW < '_ , CtrlSpec > { GptmrCtrlIrqClrW :: new (self , 30) } }
#[doc = "Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CtrlSpec ; impl crate :: RegisterSpec for CtrlSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ctrl::R`](R) reader structure"] impl crate :: Readable for CtrlSpec { }
#[doc = "`write(|w| ..)` method takes [`ctrl::W`](W) writer structure"] impl crate :: Writable for CtrlSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CTRL to value 0"] impl crate :: Resettable for CtrlSpec { } }
#[doc = "THRES (rw) register accessor: Threshold register\n\nYou can [`read`](crate::Reg::read) this register and get [`thres::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`thres::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@thres`] module"]
#[doc (alias = "THRES")] pub type Thres = crate :: Reg < thres :: ThresSpec > ;
#[doc = "Threshold register"] pub mod thres {
#[doc = "Register `THRES` reader"] pub type R = crate :: R < ThresSpec > ;
#[doc = "Register `THRES` writer"] pub type W = crate :: W < ThresSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "Threshold register\n\nYou can [`read`](crate::Reg::read) this register and get [`thres::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`thres::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ThresSpec ; impl crate :: RegisterSpec for ThresSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`thres::R`](R) reader structure"] impl crate :: Readable for ThresSpec { }
#[doc = "`write(|w| ..)` method takes [`thres::W`](W) writer structure"] impl crate :: Writable for ThresSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets THRES to value 0"] impl crate :: Resettable for ThresSpec { } }
#[doc = "COUNT (r) register accessor: Counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`count::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@count`] module"]
#[doc (alias = "COUNT")] pub type Count = crate :: Reg < count :: CountSpec > ;
#[doc = "Counter register"] pub mod count {
#[doc = "Register `COUNT` reader"] pub type R = crate :: R < CountSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } }
#[doc = "Counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`count::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CountSpec ; impl crate :: RegisterSpec for CountSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`count::R`](R) reader structure"] impl crate :: Readable for CountSpec { }
#[doc = "`reset()` method sets COUNT to value 0"] impl crate :: Resettable for CountSpec { } } }
#[doc = "1-Wire Interface Controller"] pub type Onewire = crate :: Periph < onewire :: RegisterBlock , 0xfff2_0000 > ; impl core :: fmt :: Debug for Onewire { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Onewire") . finish () } }
#[doc = "1-Wire Interface Controller"] pub mod onewire {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { ctrl : Ctrl , dcmd : Dcmd , } impl RegisterBlock {
#[doc = "0x00 - Control register"]
#[inline (always)] pub const fn ctrl (& self) -> & Ctrl { & self . ctrl }
#[doc = "0x04 - Read/write transmission data/command register"]
#[inline (always)] pub const fn dcmd (& self) -> & Dcmd { & self . dcmd } }
#[doc = "CTRL (rw) register accessor: Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl`] module"]
#[doc (alias = "CTRL")] pub type Ctrl = crate :: Reg < ctrl :: CtrlSpec > ;
#[doc = "Control register"] pub mod ctrl {
#[doc = "Register `CTRL` reader"] pub type R = crate :: R < CtrlSpec > ;
#[doc = "Register `CTRL` writer"] pub type W = crate :: W < CtrlSpec > ;
#[doc = "Field `ONEWIRE_CTRL_EN` reader - ONEWIRE controller enable"] pub type OnewireCtrlEnR = crate :: BitReader ;
#[doc = "Field `ONEWIRE_CTRL_EN` writer - ONEWIRE controller enable"] pub type OnewireCtrlEnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ONEWIRE_CTRL_CLEAR` writer - Clear RXT FIFO, auto-clears"] pub type OnewireCtrlClearW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ONEWIRE_CTRL_PRSC` reader - Clock prescaler select"] pub type OnewireCtrlPrscR = crate :: FieldReader ;
#[doc = "Field `ONEWIRE_CTRL_PRSC` writer - Clock prescaler select"] pub type OnewireCtrlPrscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `ONEWIRE_CTRL_CLKDIV` reader - Clock divider"] pub type OnewireCtrlClkdivR = crate :: FieldReader ;
#[doc = "Field `ONEWIRE_CTRL_CLKDIV` writer - Clock divider"] pub type OnewireCtrlClkdivW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `ONEWIRE_CTRL_FIFO` reader - log2(ONEWIRE FIFO size)"] pub type OnewireCtrlFifoR = crate :: FieldReader ;
#[doc = "Field `ONEWIRE_CTRL_TX_FULL` reader - TX FIFO full"] pub type OnewireCtrlTxFullR = crate :: BitReader ;
#[doc = "Field `ONEWIRE_CTRL_RX_AVAIL` reader - RX FIFO data available"] pub type OnewireCtrlRxAvailR = crate :: BitReader ;
#[doc = "Field `ONEWIRE_CTRL_SENSE` reader - Current state of the 1-wire bus line"] pub type OnewireCtrlSenseR = crate :: BitReader ;
#[doc = "Field `ONEWIRE_CTRL_BUSY` reader - Operation in progress when set"] pub type OnewireCtrlBusyR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - ONEWIRE controller enable"]
#[inline (always)] pub fn onewire_ctrl_en (& self) -> OnewireCtrlEnR { OnewireCtrlEnR :: new ((self . bits & 1) != 0) }
#[doc = "Bits 2:3 - Clock prescaler select"]
#[inline (always)] pub fn onewire_ctrl_prsc (& self) -> OnewireCtrlPrscR { OnewireCtrlPrscR :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:11 - Clock divider"]
#[inline (always)] pub fn onewire_ctrl_clkdiv (& self) -> OnewireCtrlClkdivR { OnewireCtrlClkdivR :: new (((self . bits >> 4) & 0xff) as u8) }
#[doc = "Bits 15:18 - log2(ONEWIRE FIFO size)"]
#[inline (always)] pub fn onewire_ctrl_fifo (& self) -> OnewireCtrlFifoR { OnewireCtrlFifoR :: new (((self . bits >> 15) & 0x0f) as u8) }
#[doc = "Bit 28 - TX FIFO full"]
#[inline (always)] pub fn onewire_ctrl_tx_full (& self) -> OnewireCtrlTxFullR { OnewireCtrlTxFullR :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - RX FIFO data available"]
#[inline (always)] pub fn onewire_ctrl_rx_avail (& self) -> OnewireCtrlRxAvailR { OnewireCtrlRxAvailR :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Current state of the 1-wire bus line"]
#[inline (always)] pub fn onewire_ctrl_sense (& self) -> OnewireCtrlSenseR { OnewireCtrlSenseR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Operation in progress when set"]
#[inline (always)] pub fn onewire_ctrl_busy (& self) -> OnewireCtrlBusyR { OnewireCtrlBusyR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - ONEWIRE controller enable"]
#[inline (always)] pub fn onewire_ctrl_en (& mut self) -> OnewireCtrlEnW < '_ , CtrlSpec > { OnewireCtrlEnW :: new (self , 0) }
#[doc = "Bit 1 - Clear RXT FIFO, auto-clears"]
#[inline (always)] pub fn onewire_ctrl_clear (& mut self) -> OnewireCtrlClearW < '_ , CtrlSpec > { OnewireCtrlClearW :: new (self , 1) }
#[doc = "Bits 2:3 - Clock prescaler select"]
#[inline (always)] pub fn onewire_ctrl_prsc (& mut self) -> OnewireCtrlPrscW < '_ , CtrlSpec > { OnewireCtrlPrscW :: new (self , 2) }
#[doc = "Bits 4:11 - Clock divider"]
#[inline (always)] pub fn onewire_ctrl_clkdiv (& mut self) -> OnewireCtrlClkdivW < '_ , CtrlSpec > { OnewireCtrlClkdivW :: new (self , 4) } }
#[doc = "Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CtrlSpec ; impl crate :: RegisterSpec for CtrlSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ctrl::R`](R) reader structure"] impl crate :: Readable for CtrlSpec { }
#[doc = "`write(|w| ..)` method takes [`ctrl::W`](W) writer structure"] impl crate :: Writable for CtrlSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CTRL to value 0"] impl crate :: Resettable for CtrlSpec { } }
#[doc = "DCMD (rw) register accessor: Read/write transmission data/command register\n\nYou can [`read`](crate::Reg::read) this register and get [`dcmd::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dcmd::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\n<div class=\"warning\">The register is <b>modified</b> in some way after a read operation.</div>\n\nFor information about available fields see [`mod@dcmd`] module"]
#[doc (alias = "DCMD")] pub type Dcmd = crate :: Reg < dcmd :: DcmdSpec > ;
#[doc = "Read/write transmission data/command register"] pub mod dcmd {
#[doc = "Register `DCMD` reader"] pub type R = crate :: R < DcmdSpec > ;
#[doc = "Register `DCMD` writer"] pub type W = crate :: W < DcmdSpec > ;
#[doc = "Field `ONEWIRE_DCMD_DATA` reader - RTX data, transmitted LSB-first"] pub type OnewireDcmdDataR = crate :: FieldReader ;
#[doc = "Field `ONEWIRE_DCMD_DATA` writer - RTX data, transmitted LSB-first"] pub type OnewireDcmdDataW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `ONEWIRE_DCMD_CMD` writer - Operation command"] pub type OnewireDcmdCmdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `ONEWIRE_DCMD_PRESENCE` reader - Bus presence detected"] pub type OnewireDcmdPresenceR = crate :: BitReader ; impl R {
#[doc = "Bits 0:7 - RTX data, transmitted LSB-first"]
#[inline (always)] pub fn onewire_dcmd_data (& self) -> OnewireDcmdDataR { OnewireDcmdDataR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bit 10 - Bus presence detected"]
#[inline (always)] pub fn onewire_dcmd_presence (& self) -> OnewireDcmdPresenceR { OnewireDcmdPresenceR :: new (((self . bits >> 10) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - RTX data, transmitted LSB-first"]
#[inline (always)] pub fn onewire_dcmd_data (& mut self) -> OnewireDcmdDataW < '_ , DcmdSpec > { OnewireDcmdDataW :: new (self , 0) }
#[doc = "Bits 8:9 - Operation command"]
#[inline (always)] pub fn onewire_dcmd_cmd (& mut self) -> OnewireDcmdCmdW < '_ , DcmdSpec > { OnewireDcmdCmdW :: new (self , 8) } }
#[doc = "Read/write transmission data/command register\n\nYou can [`read`](crate::Reg::read) this register and get [`dcmd::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dcmd::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\n<div class=\"warning\">The register is <b>modified</b> in some way after a read operation.</div>"] pub struct DcmdSpec ; impl crate :: RegisterSpec for DcmdSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dcmd::R`](R) reader structure"] impl crate :: Readable for DcmdSpec { }
#[doc = "`write(|w| ..)` method takes [`dcmd::W`](W) writer structure"] impl crate :: Writable for DcmdSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DCMD to value 0"] impl crate :: Resettable for DcmdSpec { } } }
#[doc = "Core local interruptor"] pub type Clint = crate :: Periph < clint :: RegisterBlock , 0xfff4_0000 > ; impl core :: fmt :: Debug for Clint { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Clint") . finish () } }
#[doc = "Core local interruptor"] pub mod clint {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { mswi0 : Mswi0 , _reserved1 : [u8 ; 0x3ffc] , mtimecmp0_low : Mtimecmp0Low , mtimecmp0_hi : Mtimecmp0Hi , _reserved3 : [u8 ; 0x7ff0] , mtime_low : MtimeLow , mtime_hi : MtimeHi , } impl RegisterBlock {
#[doc = "0x00 - Machine software interrupt; hart 0"]
#[inline (always)] pub const fn mswi0 (& self) -> & Mswi0 { & self . mswi0 }
#[doc = "0x4000 - Machine timer compare low word; hart0"]
#[inline (always)] pub const fn mtimecmp0_low (& self) -> & Mtimecmp0Low { & self . mtimecmp0_low }
#[doc = "0x4004 - Machine timer compare low word; hart0"]
#[inline (always)] pub const fn mtimecmp0_hi (& self) -> & Mtimecmp0Hi { & self . mtimecmp0_hi }
#[doc = "0xbff8 - Machine timer low word"]
#[inline (always)] pub const fn mtime_low (& self) -> & MtimeLow { & self . mtime_low }
#[doc = "0xbffc - Machine timer high word"]
#[inline (always)] pub const fn mtime_hi (& self) -> & MtimeHi { & self . mtime_hi } }
#[doc = "MSWI0 (rw) register accessor: Machine software interrupt; hart 0\n\nYou can [`read`](crate::Reg::read) this register and get [`mswi0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mswi0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mswi0`] module"]
#[doc (alias = "MSWI0")] pub type Mswi0 = crate :: Reg < mswi0 :: Mswi0Spec > ;
#[doc = "Machine software interrupt; hart 0"] pub mod mswi0 {
#[doc = "Register `MSWI0` reader"] pub type R = crate :: R < Mswi0Spec > ;
#[doc = "Register `MSWI0` writer"] pub type W = crate :: W < Mswi0Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "Machine software interrupt; hart 0\n\nYou can [`read`](crate::Reg::read) this register and get [`mswi0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mswi0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Mswi0Spec ; impl crate :: RegisterSpec for Mswi0Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`mswi0::R`](R) reader structure"] impl crate :: Readable for Mswi0Spec { }
#[doc = "`write(|w| ..)` method takes [`mswi0::W`](W) writer structure"] impl crate :: Writable for Mswi0Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MSWI0 to value 0"] impl crate :: Resettable for Mswi0Spec { } }
#[doc = "MTIMECMP0_LOW (rw) register accessor: Machine timer compare low word; hart0\n\nYou can [`read`](crate::Reg::read) this register and get [`mtimecmp0_low::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mtimecmp0_low::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mtimecmp0_low`] module"]
#[doc (alias = "MTIMECMP0_LOW")] pub type Mtimecmp0Low = crate :: Reg < mtimecmp0_low :: Mtimecmp0LowSpec > ;
#[doc = "Machine timer compare low word; hart0"] pub mod mtimecmp0_low {
#[doc = "Register `MTIMECMP0_LOW` reader"] pub type R = crate :: R < Mtimecmp0LowSpec > ;
#[doc = "Register `MTIMECMP0_LOW` writer"] pub type W = crate :: W < Mtimecmp0LowSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "Machine timer compare low word; hart0\n\nYou can [`read`](crate::Reg::read) this register and get [`mtimecmp0_low::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mtimecmp0_low::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Mtimecmp0LowSpec ; impl crate :: RegisterSpec for Mtimecmp0LowSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`mtimecmp0_low::R`](R) reader structure"] impl crate :: Readable for Mtimecmp0LowSpec { }
#[doc = "`write(|w| ..)` method takes [`mtimecmp0_low::W`](W) writer structure"] impl crate :: Writable for Mtimecmp0LowSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MTIMECMP0_LOW to value 0"] impl crate :: Resettable for Mtimecmp0LowSpec { } }
#[doc = "MTIMECMP0_HI (rw) register accessor: Machine timer compare low word; hart0\n\nYou can [`read`](crate::Reg::read) this register and get [`mtimecmp0_hi::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mtimecmp0_hi::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mtimecmp0_hi`] module"]
#[doc (alias = "MTIMECMP0_HI")] pub type Mtimecmp0Hi = crate :: Reg < mtimecmp0_hi :: Mtimecmp0HiSpec > ;
#[doc = "Machine timer compare low word; hart0"] pub mod mtimecmp0_hi {
#[doc = "Register `MTIMECMP0_HI` reader"] pub type R = crate :: R < Mtimecmp0HiSpec > ;
#[doc = "Register `MTIMECMP0_HI` writer"] pub type W = crate :: W < Mtimecmp0HiSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "Machine timer compare low word; hart0\n\nYou can [`read`](crate::Reg::read) this register and get [`mtimecmp0_hi::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mtimecmp0_hi::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Mtimecmp0HiSpec ; impl crate :: RegisterSpec for Mtimecmp0HiSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`mtimecmp0_hi::R`](R) reader structure"] impl crate :: Readable for Mtimecmp0HiSpec { }
#[doc = "`write(|w| ..)` method takes [`mtimecmp0_hi::W`](W) writer structure"] impl crate :: Writable for Mtimecmp0HiSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MTIMECMP0_HI to value 0"] impl crate :: Resettable for Mtimecmp0HiSpec { } }
#[doc = "MTIME_LOW (rw) register accessor: Machine timer low word\n\nYou can [`read`](crate::Reg::read) this register and get [`mtime_low::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mtime_low::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mtime_low`] module"]
#[doc (alias = "MTIME_LOW")] pub type MtimeLow = crate :: Reg < mtime_low :: MtimeLowSpec > ;
#[doc = "Machine timer low word"] pub mod mtime_low {
#[doc = "Register `MTIME_LOW` reader"] pub type R = crate :: R < MtimeLowSpec > ;
#[doc = "Register `MTIME_LOW` writer"] pub type W = crate :: W < MtimeLowSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "Machine timer low word\n\nYou can [`read`](crate::Reg::read) this register and get [`mtime_low::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mtime_low::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MtimeLowSpec ; impl crate :: RegisterSpec for MtimeLowSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`mtime_low::R`](R) reader structure"] impl crate :: Readable for MtimeLowSpec { }
#[doc = "`write(|w| ..)` method takes [`mtime_low::W`](W) writer structure"] impl crate :: Writable for MtimeLowSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MTIME_LOW to value 0"] impl crate :: Resettable for MtimeLowSpec { } }
#[doc = "MTIME_HI (rw) register accessor: Machine timer high word\n\nYou can [`read`](crate::Reg::read) this register and get [`mtime_hi::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mtime_hi::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mtime_hi`] module"]
#[doc (alias = "MTIME_HI")] pub type MtimeHi = crate :: Reg < mtime_hi :: MtimeHiSpec > ;
#[doc = "Machine timer high word"] pub mod mtime_hi {
#[doc = "Register `MTIME_HI` reader"] pub type R = crate :: R < MtimeHiSpec > ;
#[doc = "Register `MTIME_HI` writer"] pub type W = crate :: W < MtimeHiSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "Machine timer high word\n\nYou can [`read`](crate::Reg::read) this register and get [`mtime_hi::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mtime_hi::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MtimeHiSpec ; impl crate :: RegisterSpec for MtimeHiSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`mtime_hi::R`](R) reader structure"] impl crate :: Readable for MtimeHiSpec { }
#[doc = "`write(|w| ..)` method takes [`mtime_hi::W`](W) writer structure"] impl crate :: Writable for MtimeHiSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MTIME_HI to value 0"] impl crate :: Resettable for MtimeHiSpec { } } }
#[doc = "Primary universal asynchronous receiver and transmitter"] pub type Uart0 = crate :: Periph < uart0 :: RegisterBlock , 0xfff5_0000 > ; impl core :: fmt :: Debug for Uart0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Uart0") . finish () } }
#[doc = "Primary universal asynchronous receiver and transmitter"] pub mod uart0 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { ctrl : Ctrl , data : Data , } impl RegisterBlock {
#[doc = "0x00 - Control register"]
#[inline (always)] pub const fn ctrl (& self) -> & Ctrl { & self . ctrl }
#[doc = "0x04 - RTX data register"]
#[inline (always)] pub const fn data (& self) -> & Data { & self . data } }
#[doc = "CTRL (rw) register accessor: Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl`] module"]
#[doc (alias = "CTRL")] pub type Ctrl = crate :: Reg < ctrl :: CtrlSpec > ;
#[doc = "Control register"] pub mod ctrl {
#[doc = "Register `CTRL` reader"] pub type R = crate :: R < CtrlSpec > ;
#[doc = "Register `CTRL` writer"] pub type W = crate :: W < CtrlSpec > ;
#[doc = "Field `UART_CTRL_EN` reader - UART enable flag"] pub type UartCtrlEnR = crate :: BitReader ;
#[doc = "Field `UART_CTRL_EN` writer - UART enable flag"] pub type UartCtrlEnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UART_CTRL_SIM_MODE` reader - Simulation output override enable, for use in simulation only"] pub type UartCtrlSimModeR = crate :: BitReader ;
#[doc = "Field `UART_CTRL_SIM_MODE` writer - Simulation output override enable, for use in simulation only"] pub type UartCtrlSimModeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UART_CTRL_HWFC_EN` reader - Enable RTS/CTS hardware flow-control"] pub type UartCtrlHwfcEnR = crate :: BitReader ;
#[doc = "Field `UART_CTRL_HWFC_EN` writer - Enable RTS/CTS hardware flow-control"] pub type UartCtrlHwfcEnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UART_CTRL_PRSC` reader - CLock prescaler select"] pub type UartCtrlPrscR = crate :: FieldReader ;
#[doc = "Field `UART_CTRL_PRSC` writer - CLock prescaler select"] pub type UartCtrlPrscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `UART_CTRL_BAUD` reader - BAUD rate divisor"] pub type UartCtrlBaudR = crate :: FieldReader < u16 > ;
#[doc = "Field `UART_CTRL_BAUD` writer - BAUD rate divisor"] pub type UartCtrlBaudW < 'a , REG > = crate :: FieldWriter < 'a , REG , 10 , u16 > ;
#[doc = "Field `UART_CTRL_RX_NEMPTY` reader - RX FIFO not empty"] pub type UartCtrlRxNemptyR = crate :: BitReader ;
#[doc = "Field `UART_CTRL_RX_FULL` reader - RX FIFO full"] pub type UartCtrlRxFullR = crate :: BitReader ;
#[doc = "Field `UART_CTRL_TX_EMPTY` reader - TX FIFO empty"] pub type UartCtrlTxEmptyR = crate :: BitReader ;
#[doc = "Field `UART_CTRL_TX_NFULL` reader - TX FIFO not full"] pub type UartCtrlTxNfullR = crate :: BitReader ;
#[doc = "Field `UART_CTRL_IRQ_RX_NEMPTY` reader - Fire IRQ if RX FIFO not empty"] pub type UartCtrlIrqRxNemptyR = crate :: BitReader ;
#[doc = "Field `UART_CTRL_IRQ_RX_NEMPTY` writer - Fire IRQ if RX FIFO not empty"] pub type UartCtrlIrqRxNemptyW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UART_CTRL_IRQ_RX_FULL` reader - Fire IRQ if RX FIFO full"] pub type UartCtrlIrqRxFullR = crate :: BitReader ;
#[doc = "Field `UART_CTRL_IRQ_RX_FULL` writer - Fire IRQ if RX FIFO full"] pub type UartCtrlIrqRxFullW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UART_CTRL_IRQ_TX_EMPTY` reader - Fire IRQ if TX FIFO empty"] pub type UartCtrlIrqTxEmptyR = crate :: BitReader ;
#[doc = "Field `UART_CTRL_IRQ_TX_EMPTY` writer - Fire IRQ if TX FIFO empty"] pub type UartCtrlIrqTxEmptyW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UART_CTRL_IRQ_TX_NFULL` reader - Fire IRQ if TX FIFO not full"] pub type UartCtrlIrqTxNfullR = crate :: BitReader ;
#[doc = "Field `UART_CTRL_IRQ_TX_NFULL` writer - Fire IRQ if TX FIFO not full"] pub type UartCtrlIrqTxNfullW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UART_CTRL_RX_OVER` reader - RX FIFO overflow"] pub type UartCtrlRxOverR = crate :: BitReader ;
#[doc = "Field `UART_CTRL_TX_BUSY` reader - Transmitter busy or TX FIFO not empty"] pub type UartCtrlTxBusyR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - UART enable flag"]
#[inline (always)] pub fn uart_ctrl_en (& self) -> UartCtrlEnR { UartCtrlEnR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Simulation output override enable, for use in simulation only"]
#[inline (always)] pub fn uart_ctrl_sim_mode (& self) -> UartCtrlSimModeR { UartCtrlSimModeR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Enable RTS/CTS hardware flow-control"]
#[inline (always)] pub fn uart_ctrl_hwfc_en (& self) -> UartCtrlHwfcEnR { UartCtrlHwfcEnR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bits 3:5 - CLock prescaler select"]
#[inline (always)] pub fn uart_ctrl_prsc (& self) -> UartCtrlPrscR { UartCtrlPrscR :: new (((self . bits >> 3) & 7) as u8) }
#[doc = "Bits 6:15 - BAUD rate divisor"]
#[inline (always)] pub fn uart_ctrl_baud (& self) -> UartCtrlBaudR { UartCtrlBaudR :: new (((self . bits >> 6) & 0x03ff) as u16) }
#[doc = "Bit 16 - RX FIFO not empty"]
#[inline (always)] pub fn uart_ctrl_rx_nempty (& self) -> UartCtrlRxNemptyR { UartCtrlRxNemptyR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - RX FIFO full"]
#[inline (always)] pub fn uart_ctrl_rx_full (& self) -> UartCtrlRxFullR { UartCtrlRxFullR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - TX FIFO empty"]
#[inline (always)] pub fn uart_ctrl_tx_empty (& self) -> UartCtrlTxEmptyR { UartCtrlTxEmptyR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - TX FIFO not full"]
#[inline (always)] pub fn uart_ctrl_tx_nfull (& self) -> UartCtrlTxNfullR { UartCtrlTxNfullR :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Fire IRQ if RX FIFO not empty"]
#[inline (always)] pub fn uart_ctrl_irq_rx_nempty (& self) -> UartCtrlIrqRxNemptyR { UartCtrlIrqRxNemptyR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Fire IRQ if RX FIFO full"]
#[inline (always)] pub fn uart_ctrl_irq_rx_full (& self) -> UartCtrlIrqRxFullR { UartCtrlIrqRxFullR :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - Fire IRQ if TX FIFO empty"]
#[inline (always)] pub fn uart_ctrl_irq_tx_empty (& self) -> UartCtrlIrqTxEmptyR { UartCtrlIrqTxEmptyR :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Fire IRQ if TX FIFO not full"]
#[inline (always)] pub fn uart_ctrl_irq_tx_nfull (& self) -> UartCtrlIrqTxNfullR { UartCtrlIrqTxNfullR :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 30 - RX FIFO overflow"]
#[inline (always)] pub fn uart_ctrl_rx_over (& self) -> UartCtrlRxOverR { UartCtrlRxOverR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Transmitter busy or TX FIFO not empty"]
#[inline (always)] pub fn uart_ctrl_tx_busy (& self) -> UartCtrlTxBusyR { UartCtrlTxBusyR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - UART enable flag"]
#[inline (always)] pub fn uart_ctrl_en (& mut self) -> UartCtrlEnW < '_ , CtrlSpec > { UartCtrlEnW :: new (self , 0) }
#[doc = "Bit 1 - Simulation output override enable, for use in simulation only"]
#[inline (always)] pub fn uart_ctrl_sim_mode (& mut self) -> UartCtrlSimModeW < '_ , CtrlSpec > { UartCtrlSimModeW :: new (self , 1) }
#[doc = "Bit 2 - Enable RTS/CTS hardware flow-control"]
#[inline (always)] pub fn uart_ctrl_hwfc_en (& mut self) -> UartCtrlHwfcEnW < '_ , CtrlSpec > { UartCtrlHwfcEnW :: new (self , 2) }
#[doc = "Bits 3:5 - CLock prescaler select"]
#[inline (always)] pub fn uart_ctrl_prsc (& mut self) -> UartCtrlPrscW < '_ , CtrlSpec > { UartCtrlPrscW :: new (self , 3) }
#[doc = "Bits 6:15 - BAUD rate divisor"]
#[inline (always)] pub fn uart_ctrl_baud (& mut self) -> UartCtrlBaudW < '_ , CtrlSpec > { UartCtrlBaudW :: new (self , 6) }
#[doc = "Bit 20 - Fire IRQ if RX FIFO not empty"]
#[inline (always)] pub fn uart_ctrl_irq_rx_nempty (& mut self) -> UartCtrlIrqRxNemptyW < '_ , CtrlSpec > { UartCtrlIrqRxNemptyW :: new (self , 20) }
#[doc = "Bit 21 - Fire IRQ if RX FIFO full"]
#[inline (always)] pub fn uart_ctrl_irq_rx_full (& mut self) -> UartCtrlIrqRxFullW < '_ , CtrlSpec > { UartCtrlIrqRxFullW :: new (self , 21) }
#[doc = "Bit 22 - Fire IRQ if TX FIFO empty"]
#[inline (always)] pub fn uart_ctrl_irq_tx_empty (& mut self) -> UartCtrlIrqTxEmptyW < '_ , CtrlSpec > { UartCtrlIrqTxEmptyW :: new (self , 22) }
#[doc = "Bit 23 - Fire IRQ if TX FIFO not full"]
#[inline (always)] pub fn uart_ctrl_irq_tx_nfull (& mut self) -> UartCtrlIrqTxNfullW < '_ , CtrlSpec > { UartCtrlIrqTxNfullW :: new (self , 23) } }
#[doc = "Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CtrlSpec ; impl crate :: RegisterSpec for CtrlSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ctrl::R`](R) reader structure"] impl crate :: Readable for CtrlSpec { }
#[doc = "`write(|w| ..)` method takes [`ctrl::W`](W) writer structure"] impl crate :: Writable for CtrlSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CTRL to value 0"] impl crate :: Resettable for CtrlSpec { } }
#[doc = "DATA (rw) register accessor: RTX data register\n\nYou can [`read`](crate::Reg::read) this register and get [`data::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`data::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\n<div class=\"warning\">The register is <b>modified</b> in some way after a read operation.</div>\n\nFor information about available fields see [`mod@data`] module"]
#[doc (alias = "DATA")] pub type Data = crate :: Reg < data :: DataSpec > ;
#[doc = "RTX data register"] pub mod data {
#[doc = "Register `DATA` reader"] pub type R = crate :: R < DataSpec > ;
#[doc = "Register `DATA` writer"] pub type W = crate :: W < DataSpec > ; impl core :: fmt :: Debug for crate :: generic :: Reg < DataSpec > { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { write ! (f , "(not readable)") } } impl W { }
#[doc = "RTX data register\n\nYou can [`read`](crate::Reg::read) this register and get [`data::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`data::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\n<div class=\"warning\">The register is <b>modified</b> in some way after a read operation.</div>"] pub struct DataSpec ; impl crate :: RegisterSpec for DataSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`data::R`](R) reader structure"] impl crate :: Readable for DataSpec { }
#[doc = "`write(|w| ..)` method takes [`data::W`](W) writer structure"] impl crate :: Writable for DataSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DATA to value 0"] impl crate :: Resettable for DataSpec { } } }
#[doc = "Secondary universal asynchronous receiver and transmitter"] pub type Uart1 = crate :: Periph < uart0 :: RegisterBlock , 0xfff6_0000 > ; impl core :: fmt :: Debug for Uart1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Uart1") . finish () } }
#[doc = "Secondary universal asynchronous receiver and transmitter"] pub use self :: uart0 as uart1 ;
#[doc = "Serial peripheral interface controller"] pub type Spi = crate :: Periph < spi :: RegisterBlock , 0xfff8_0000 > ; impl core :: fmt :: Debug for Spi { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Spi") . finish () } }
#[doc = "Serial peripheral interface controller"] pub mod spi {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { ctrl : Ctrl , data : Data , } impl RegisterBlock {
#[doc = "0x00 - Control register"]
#[inline (always)] pub const fn ctrl (& self) -> & Ctrl { & self . ctrl }
#[doc = "0x04 - Data register"]
#[inline (always)] pub const fn data (& self) -> & Data { & self . data } }
#[doc = "CTRL (rw) register accessor: Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl`] module"]
#[doc (alias = "CTRL")] pub type Ctrl = crate :: Reg < ctrl :: CtrlSpec > ;
#[doc = "Control register"] pub mod ctrl {
#[doc = "Register `CTRL` reader"] pub type R = crate :: R < CtrlSpec > ;
#[doc = "Register `CTRL` writer"] pub type W = crate :: W < CtrlSpec > ;
#[doc = "Field `SPI_CTRL_EN` reader - SPI enable flag"] pub type SpiCtrlEnR = crate :: BitReader ;
#[doc = "Field `SPI_CTRL_EN` writer - SPI enable flag"] pub type SpiCtrlEnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPI_CTRL_CPHA` reader - Clock phase"] pub type SpiCtrlCphaR = crate :: BitReader ;
#[doc = "Field `SPI_CTRL_CPHA` writer - Clock phase"] pub type SpiCtrlCphaW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPI_CTRL_CPOL` reader - Clock polarity"] pub type SpiCtrlCpolR = crate :: BitReader ;
#[doc = "Field `SPI_CTRL_CPOL` writer - Clock polarity"] pub type SpiCtrlCpolW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPI_CTRL_PRSC` reader - Clock prescaler select"] pub type SpiCtrlPrscR = crate :: FieldReader ;
#[doc = "Field `SPI_CTRL_PRSC` writer - Clock prescaler select"] pub type SpiCtrlPrscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SPI_CTRL_CDIV` reader - SPI clock divider"] pub type SpiCtrlCdivR = crate :: FieldReader ;
#[doc = "Field `SPI_CTRL_CDIV` writer - SPI clock divider"] pub type SpiCtrlCdivW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `SPI_CTRL_RX_AVAIL` reader - RX FIFO data available (RX FIFO not empty)"] pub type SpiCtrlRxAvailR = crate :: BitReader ;
#[doc = "Field `SPI_CTRL_TX_EMPTY` reader - TX FIFO is empty"] pub type SpiCtrlTxEmptyR = crate :: BitReader ;
#[doc = "Field `SPI_CTRL_TX_FULL` reader - TX FIFO is full"] pub type SpiCtrlTxFullR = crate :: BitReader ;
#[doc = "Field `SPI_CTRL_FIFO` reader - log2(FIFO size)"] pub type SpiCtrlFifoR = crate :: FieldReader ;
#[doc = "Field `SPI_CS_ACTIVE` reader - Set if a chip-select line is active"] pub type SpiCsActiveR = crate :: BitReader ;
#[doc = "Field `SPI_CTRL_BUSY` reader - SPI busy flag (transmission in progress and TX FIFO not empty)"] pub type SpiCtrlBusyR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - SPI enable flag"]
#[inline (always)] pub fn spi_ctrl_en (& self) -> SpiCtrlEnR { SpiCtrlEnR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Clock phase"]
#[inline (always)] pub fn spi_ctrl_cpha (& self) -> SpiCtrlCphaR { SpiCtrlCphaR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Clock polarity"]
#[inline (always)] pub fn spi_ctrl_cpol (& self) -> SpiCtrlCpolR { SpiCtrlCpolR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bits 3:5 - Clock prescaler select"]
#[inline (always)] pub fn spi_ctrl_prsc (& self) -> SpiCtrlPrscR { SpiCtrlPrscR :: new (((self . bits >> 3) & 7) as u8) }
#[doc = "Bits 6:9 - SPI clock divider"]
#[inline (always)] pub fn spi_ctrl_cdiv (& self) -> SpiCtrlCdivR { SpiCtrlCdivR :: new (((self . bits >> 6) & 0x0f) as u8) }
#[doc = "Bit 16 - RX FIFO data available (RX FIFO not empty)"]
#[inline (always)] pub fn spi_ctrl_rx_avail (& self) -> SpiCtrlRxAvailR { SpiCtrlRxAvailR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - TX FIFO is empty"]
#[inline (always)] pub fn spi_ctrl_tx_empty (& self) -> SpiCtrlTxEmptyR { SpiCtrlTxEmptyR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - TX FIFO is full"]
#[inline (always)] pub fn spi_ctrl_tx_full (& self) -> SpiCtrlTxFullR { SpiCtrlTxFullR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bits 24:27 - log2(FIFO size)"]
#[inline (always)] pub fn spi_ctrl_fifo (& self) -> SpiCtrlFifoR { SpiCtrlFifoR :: new (((self . bits >> 24) & 0x0f) as u8) }
#[doc = "Bit 30 - Set if a chip-select line is active"]
#[inline (always)] pub fn spi_cs_active (& self) -> SpiCsActiveR { SpiCsActiveR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - SPI busy flag (transmission in progress and TX FIFO not empty)"]
#[inline (always)] pub fn spi_ctrl_busy (& self) -> SpiCtrlBusyR { SpiCtrlBusyR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - SPI enable flag"]
#[inline (always)] pub fn spi_ctrl_en (& mut self) -> SpiCtrlEnW < '_ , CtrlSpec > { SpiCtrlEnW :: new (self , 0) }
#[doc = "Bit 1 - Clock phase"]
#[inline (always)] pub fn spi_ctrl_cpha (& mut self) -> SpiCtrlCphaW < '_ , CtrlSpec > { SpiCtrlCphaW :: new (self , 1) }
#[doc = "Bit 2 - Clock polarity"]
#[inline (always)] pub fn spi_ctrl_cpol (& mut self) -> SpiCtrlCpolW < '_ , CtrlSpec > { SpiCtrlCpolW :: new (self , 2) }
#[doc = "Bits 3:5 - Clock prescaler select"]
#[inline (always)] pub fn spi_ctrl_prsc (& mut self) -> SpiCtrlPrscW < '_ , CtrlSpec > { SpiCtrlPrscW :: new (self , 3) }
#[doc = "Bits 6:9 - SPI clock divider"]
#[inline (always)] pub fn spi_ctrl_cdiv (& mut self) -> SpiCtrlCdivW < '_ , CtrlSpec > { SpiCtrlCdivW :: new (self , 6) } }
#[doc = "Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CtrlSpec ; impl crate :: RegisterSpec for CtrlSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ctrl::R`](R) reader structure"] impl crate :: Readable for CtrlSpec { }
#[doc = "`write(|w| ..)` method takes [`ctrl::W`](W) writer structure"] impl crate :: Writable for CtrlSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CTRL to value 0"] impl crate :: Resettable for CtrlSpec { } }
#[doc = "DATA (rw) register accessor: Data register\n\nYou can [`read`](crate::Reg::read) this register and get [`data::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`data::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\n<div class=\"warning\">The register is <b>modified</b> in some way after a read operation.</div>\n\nFor information about available fields see [`mod@data`] module"]
#[doc (alias = "DATA")] pub type Data = crate :: Reg < data :: DataSpec > ;
#[doc = "Data register"] pub mod data {
#[doc = "Register `DATA` reader"] pub type R = crate :: R < DataSpec > ;
#[doc = "Register `DATA` writer"] pub type W = crate :: W < DataSpec > ;
#[doc = "Field `SPI_DATA` reader - RX data / TX data/command (via FIFOs)"] pub type SpiDataR = crate :: FieldReader ;
#[doc = "Field `SPI_DATA` writer - RX data / TX data/command (via FIFOs)"] pub type SpiDataW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `SPI_DATA_CMD` writer - SPI TX data (0) / command (1) select"] pub type SpiDataCmdW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - RX data / TX data/command (via FIFOs)"]
#[inline (always)] pub fn spi_data (& self) -> SpiDataR { SpiDataR :: new ((self . bits & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - RX data / TX data/command (via FIFOs)"]
#[inline (always)] pub fn spi_data (& mut self) -> SpiDataW < '_ , DataSpec > { SpiDataW :: new (self , 0) }
#[doc = "Bit 31 - SPI TX data (0) / command (1) select"]
#[inline (always)] pub fn spi_data_cmd (& mut self) -> SpiDataCmdW < '_ , DataSpec > { SpiDataCmdW :: new (self , 31) } }
#[doc = "Data register\n\nYou can [`read`](crate::Reg::read) this register and get [`data::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`data::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\n<div class=\"warning\">The register is <b>modified</b> in some way after a read operation.</div>"] pub struct DataSpec ; impl crate :: RegisterSpec for DataSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`data::R`](R) reader structure"] impl crate :: Readable for DataSpec { }
#[doc = "`write(|w| ..)` method takes [`data::W`](W) writer structure"] impl crate :: Writable for DataSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DATA to value 0"] impl crate :: Resettable for DataSpec { } } }
#[doc = "Two-wire interface controller"] pub type Twi = crate :: Periph < twi :: RegisterBlock , 0xfff9_0000 > ; impl core :: fmt :: Debug for Twi { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Twi") . finish () } }
#[doc = "Two-wire interface controller"] pub mod twi {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { ctrl : Ctrl , dcmd : Dcmd , } impl RegisterBlock {
#[doc = "0x00 - Control register"]
#[inline (always)] pub const fn ctrl (& self) -> & Ctrl { & self . ctrl }
#[doc = "0x04 - RX/TX data/command register"]
#[inline (always)] pub const fn dcmd (& self) -> & Dcmd { & self . dcmd } }
#[doc = "CTRL (rw) register accessor: Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl`] module"]
#[doc (alias = "CTRL")] pub type Ctrl = crate :: Reg < ctrl :: CtrlSpec > ;
#[doc = "Control register"] pub mod ctrl {
#[doc = "Register `CTRL` reader"] pub type R = crate :: R < CtrlSpec > ;
#[doc = "Register `CTRL` writer"] pub type W = crate :: W < CtrlSpec > ;
#[doc = "Field `TWI_CTRL_EN` reader - TWI enable flag"] pub type TwiCtrlEnR = crate :: BitReader ;
#[doc = "Field `TWI_CTRL_EN` writer - TWI enable flag"] pub type TwiCtrlEnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TWI_CTRL_PRSC` reader - Clock prescaler select"] pub type TwiCtrlPrscR = crate :: FieldReader ;
#[doc = "Field `TWI_CTRL_PRSC` writer - Clock prescaler select"] pub type TwiCtrlPrscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `TWI_CTRL_CDIV` reader - TWI clock divider"] pub type TwiCtrlCdivR = crate :: FieldReader ;
#[doc = "Field `TWI_CTRL_CDIV` writer - TWI clock divider"] pub type TwiCtrlCdivW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `TWI_CTRL_CLKSTR` reader - Enable (allow) clock stretching"] pub type TwiCtrlClkstrR = crate :: BitReader ;
#[doc = "Field `TWI_CTRL_CLKSTR` writer - Enable (allow) clock stretching"] pub type TwiCtrlClkstrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TWI_CTRL_FIFO` reader - log2(TWI FIFO size)"] pub type TwiCtrlFifoR = crate :: FieldReader ;
#[doc = "Field `TWI_CTRL_SENSE_SCL` reader - current state of the SCL bus line"] pub type TwiCtrlSenseSclR = crate :: BitReader ;
#[doc = "Field `TWI_CTRL_SENSE_SDA` reader - current state of the SDA bus line"] pub type TwiCtrlSenseSdaR = crate :: BitReader ;
#[doc = "Field `TWI_CTRL_TX_FULL` reader - TX FIFO full"] pub type TwiCtrlTxFullR = crate :: BitReader ;
#[doc = "Field `TWI_CTRL_RX_AVAIL` reader - RX FIFO not empty (data available)"] pub type TwiCtrlRxAvailR = crate :: BitReader ;
#[doc = "Field `TWI_CTRL_BUSY` reader - Bus engine busy of TX FIFO not empty"] pub type TwiCtrlBusyR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - TWI enable flag"]
#[inline (always)] pub fn twi_ctrl_en (& self) -> TwiCtrlEnR { TwiCtrlEnR :: new ((self . bits & 1) != 0) }
#[doc = "Bits 1:3 - Clock prescaler select"]
#[inline (always)] pub fn twi_ctrl_prsc (& self) -> TwiCtrlPrscR { TwiCtrlPrscR :: new (((self . bits >> 1) & 7) as u8) }
#[doc = "Bits 4:7 - TWI clock divider"]
#[inline (always)] pub fn twi_ctrl_cdiv (& self) -> TwiCtrlCdivR { TwiCtrlCdivR :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bit 8 - Enable (allow) clock stretching"]
#[inline (always)] pub fn twi_ctrl_clkstr (& self) -> TwiCtrlClkstrR { TwiCtrlClkstrR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bits 15:18 - log2(TWI FIFO size)"]
#[inline (always)] pub fn twi_ctrl_fifo (& self) -> TwiCtrlFifoR { TwiCtrlFifoR :: new (((self . bits >> 15) & 0x0f) as u8) }
#[doc = "Bit 27 - current state of the SCL bus line"]
#[inline (always)] pub fn twi_ctrl_sense_scl (& self) -> TwiCtrlSenseSclR { TwiCtrlSenseSclR :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - current state of the SDA bus line"]
#[inline (always)] pub fn twi_ctrl_sense_sda (& self) -> TwiCtrlSenseSdaR { TwiCtrlSenseSdaR :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - TX FIFO full"]
#[inline (always)] pub fn twi_ctrl_tx_full (& self) -> TwiCtrlTxFullR { TwiCtrlTxFullR :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - RX FIFO not empty (data available)"]
#[inline (always)] pub fn twi_ctrl_rx_avail (& self) -> TwiCtrlRxAvailR { TwiCtrlRxAvailR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Bus engine busy of TX FIFO not empty"]
#[inline (always)] pub fn twi_ctrl_busy (& self) -> TwiCtrlBusyR { TwiCtrlBusyR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - TWI enable flag"]
#[inline (always)] pub fn twi_ctrl_en (& mut self) -> TwiCtrlEnW < '_ , CtrlSpec > { TwiCtrlEnW :: new (self , 0) }
#[doc = "Bits 1:3 - Clock prescaler select"]
#[inline (always)] pub fn twi_ctrl_prsc (& mut self) -> TwiCtrlPrscW < '_ , CtrlSpec > { TwiCtrlPrscW :: new (self , 1) }
#[doc = "Bits 4:7 - TWI clock divider"]
#[inline (always)] pub fn twi_ctrl_cdiv (& mut self) -> TwiCtrlCdivW < '_ , CtrlSpec > { TwiCtrlCdivW :: new (self , 4) }
#[doc = "Bit 8 - Enable (allow) clock stretching"]
#[inline (always)] pub fn twi_ctrl_clkstr (& mut self) -> TwiCtrlClkstrW < '_ , CtrlSpec > { TwiCtrlClkstrW :: new (self , 8) } }
#[doc = "Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CtrlSpec ; impl crate :: RegisterSpec for CtrlSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ctrl::R`](R) reader structure"] impl crate :: Readable for CtrlSpec { }
#[doc = "`write(|w| ..)` method takes [`ctrl::W`](W) writer structure"] impl crate :: Writable for CtrlSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CTRL to value 0"] impl crate :: Resettable for CtrlSpec { } }
#[doc = "DCMD (rw) register accessor: RX/TX data/command register\n\nYou can [`read`](crate::Reg::read) this register and get [`dcmd::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dcmd::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\n<div class=\"warning\">The register is <b>modified</b> in some way after a read operation.</div>\n\nFor information about available fields see [`mod@dcmd`] module"]
#[doc (alias = "DCMD")] pub type Dcmd = crate :: Reg < dcmd :: DcmdSpec > ;
#[doc = "RX/TX data/command register"] pub mod dcmd {
#[doc = "Register `DCMD` reader"] pub type R = crate :: R < DcmdSpec > ;
#[doc = "Register `DCMD` writer"] pub type W = crate :: W < DcmdSpec > ;
#[doc = "Field `TWI_DCMD` reader - RX/TX data"] pub type TwiDcmdR = crate :: FieldReader ;
#[doc = "Field `TWI_DCMD` writer - RX/TX data"] pub type TwiDcmdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `TWI_DCMD_ACK` reader - RX = ACK/NACK, TX = MACK"] pub type TwiDcmdAckR = crate :: BitReader ;
#[doc = "Field `TWI_DCMD_ACK` writer - RX = ACK/NACK, TX = MACK"] pub type TwiDcmdAckW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TWI_DCMD_CMD` reader - Operation command"] pub type TwiDcmdCmdR = crate :: FieldReader ;
#[doc = "Field `TWI_DCMD_CMD` writer - Operation command"] pub type TwiDcmdCmdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:7 - RX/TX data"]
#[inline (always)] pub fn twi_dcmd (& self) -> TwiDcmdR { TwiDcmdR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bit 8 - RX = ACK/NACK, TX = MACK"]
#[inline (always)] pub fn twi_dcmd_ack (& self) -> TwiDcmdAckR { TwiDcmdAckR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bits 9:10 - Operation command"]
#[inline (always)] pub fn twi_dcmd_cmd (& self) -> TwiDcmdCmdR { TwiDcmdCmdR :: new (((self . bits >> 9) & 3) as u8) } } impl W {
#[doc = "Bits 0:7 - RX/TX data"]
#[inline (always)] pub fn twi_dcmd (& mut self) -> TwiDcmdW < '_ , DcmdSpec > { TwiDcmdW :: new (self , 0) }
#[doc = "Bit 8 - RX = ACK/NACK, TX = MACK"]
#[inline (always)] pub fn twi_dcmd_ack (& mut self) -> TwiDcmdAckW < '_ , DcmdSpec > { TwiDcmdAckW :: new (self , 8) }
#[doc = "Bits 9:10 - Operation command"]
#[inline (always)] pub fn twi_dcmd_cmd (& mut self) -> TwiDcmdCmdW < '_ , DcmdSpec > { TwiDcmdCmdW :: new (self , 9) } }
#[doc = "RX/TX data/command register\n\nYou can [`read`](crate::Reg::read) this register and get [`dcmd::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dcmd::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\n<div class=\"warning\">The register is <b>modified</b> in some way after a read operation.</div>"] pub struct DcmdSpec ; impl crate :: RegisterSpec for DcmdSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dcmd::R`](R) reader structure"] impl crate :: Readable for DcmdSpec { }
#[doc = "`write(|w| ..)` method takes [`dcmd::W`](W) writer structure"] impl crate :: Writable for DcmdSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DCMD to value 0"] impl crate :: Resettable for DcmdSpec { } } }
#[doc = "Two-wire device controller"] pub type Twd = crate :: Periph < twd :: RegisterBlock , 0xffea_0000 > ; impl core :: fmt :: Debug for Twd { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Twd") . finish () } }
#[doc = "Two-wire device controller"] pub mod twd {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { ctrl : Ctrl , data : Data , } impl RegisterBlock {
#[doc = "0x00 - Control register"]
#[inline (always)] pub const fn ctrl (& self) -> & Ctrl { & self . ctrl }
#[doc = "0x04 - RX/TX data register"]
#[inline (always)] pub const fn data (& self) -> & Data { & self . data } }
#[doc = "CTRL (rw) register accessor: Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl`] module"]
#[doc (alias = "CTRL")] pub type Ctrl = crate :: Reg < ctrl :: CtrlSpec > ;
#[doc = "Control register"] pub mod ctrl {
#[doc = "Register `CTRL` reader"] pub type R = crate :: R < CtrlSpec > ;
#[doc = "Register `CTRL` writer"] pub type W = crate :: W < CtrlSpec > ;
#[doc = "Field `TWD_CTRL_EN` reader - TWD enable flag"] pub type TwdCtrlEnR = crate :: BitReader ;
#[doc = "Field `TWD_CTRL_EN` writer - TWD enable flag"] pub type TwdCtrlEnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TWD_CTRL_CLR_RX` writer - Clear RX FIFO, flag auto-clears"] pub type TwdCtrlClrRxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TWD_CTRL_CLR_TX` writer - Clear TX FIFO, flag auto-clears"] pub type TwdCtrlClrTxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TWD_CTRL_FSEL` reader - Bus sample clock / filter select"] pub type TwdCtrlFselR = crate :: BitReader ;
#[doc = "Field `TWD_CTRL_FSEL` writer - Bus sample clock / filter select"] pub type TwdCtrlFselW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TWD_CTRL_DEV_ADDR` reader - Device address (7-bit)"] pub type TwdCtrlDevAddrR = crate :: FieldReader ;
#[doc = "Field `TWD_CTRL_DEV_ADDR` writer - Device address (7-bit)"] pub type TwdCtrlDevAddrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ;
#[doc = "Field `TWD_CTRL_IRQ_RX_AVAIL` reader - IRQ if RX FIFO data available"] pub type TwdCtrlIrqRxAvailR = crate :: BitReader ;
#[doc = "Field `TWD_CTRL_IRQ_RX_AVAIL` writer - IRQ if RX FIFO data available"] pub type TwdCtrlIrqRxAvailW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TWD_CTRL_IRQ_RX_FULL` reader - IRQ if RX FIFO full"] pub type TwdCtrlIrqRxFullR = crate :: BitReader ;
#[doc = "Field `TWD_CTRL_IRQ_RX_FULL` writer - IRQ if RX FIFO full"] pub type TwdCtrlIrqRxFullW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TWD_CTRL_IRQ_TX_EMPTY` reader - IRQ if TX FIFO empty"] pub type TwdCtrlIrqTxEmptyR = crate :: BitReader ;
#[doc = "Field `TWD_CTRL_IRQ_TX_EMPTY` writer - IRQ if TX FIFO empty"] pub type TwdCtrlIrqTxEmptyW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TWD_CTRL_RX_FIFO` reader - log2(TWD RX FIFO size)"] pub type TwdCtrlRxFifoR = crate :: FieldReader ;
#[doc = "Field `TWD_CTRL_TX_FIFO` reader - log2(TWD TX FIFO size)"] pub type TwdCtrlTxFifoR = crate :: FieldReader ;
#[doc = "Field `TWD_CTRL_RX_AVAIL` reader - RX FIFO data available"] pub type TwdCtrlRxAvailR = crate :: BitReader ;
#[doc = "Field `TWD_CTRL_RX_FULL` reader - RX FIFO full"] pub type TwdCtrlRxFullR = crate :: BitReader ;
#[doc = "Field `TWD_CTRL_TX_EMPTY` reader - TX FIFO empty"] pub type TwdCtrlTxEmptyR = crate :: BitReader ;
#[doc = "Field `TWD_CTRL_TX_FULL` reader - TX FIFO full"] pub type TwdCtrlTxFullR = crate :: BitReader ;
#[doc = "Field `TWD_CTRL_SENSE_SCL` reader - current state of the SCL bus line"] pub type TwdCtrlSenseSclR = crate :: BitReader ;
#[doc = "Field `TWD_CTRL_SENSE_SDA` reader - current state of the SDA bus line"] pub type TwdCtrlSenseSdaR = crate :: BitReader ;
#[doc = "Field `TWD_CTRL_BUSY` reader - bus engine is busy (transaction in progress)"] pub type TwdCtrlBusyR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - TWD enable flag"]
#[inline (always)] pub fn twd_ctrl_en (& self) -> TwdCtrlEnR { TwdCtrlEnR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 3 - Bus sample clock / filter select"]
#[inline (always)] pub fn twd_ctrl_fsel (& self) -> TwdCtrlFselR { TwdCtrlFselR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:10 - Device address (7-bit)"]
#[inline (always)] pub fn twd_ctrl_dev_addr (& self) -> TwdCtrlDevAddrR { TwdCtrlDevAddrR :: new (((self . bits >> 4) & 0x7f) as u8) }
#[doc = "Bit 11 - IRQ if RX FIFO data available"]
#[inline (always)] pub fn twd_ctrl_irq_rx_avail (& self) -> TwdCtrlIrqRxAvailR { TwdCtrlIrqRxAvailR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - IRQ if RX FIFO full"]
#[inline (always)] pub fn twd_ctrl_irq_rx_full (& self) -> TwdCtrlIrqRxFullR { TwdCtrlIrqRxFullR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - IRQ if TX FIFO empty"]
#[inline (always)] pub fn twd_ctrl_irq_tx_empty (& self) -> TwdCtrlIrqTxEmptyR { TwdCtrlIrqTxEmptyR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bits 16:19 - log2(TWD RX FIFO size)"]
#[inline (always)] pub fn twd_ctrl_rx_fifo (& self) -> TwdCtrlRxFifoR { TwdCtrlRxFifoR :: new (((self . bits >> 16) & 0x0f) as u8) }
#[doc = "Bits 20:23 - log2(TWD TX FIFO size)"]
#[inline (always)] pub fn twd_ctrl_tx_fifo (& self) -> TwdCtrlTxFifoR { TwdCtrlTxFifoR :: new (((self . bits >> 20) & 0x0f) as u8) }
#[doc = "Bit 25 - RX FIFO data available"]
#[inline (always)] pub fn twd_ctrl_rx_avail (& self) -> TwdCtrlRxAvailR { TwdCtrlRxAvailR :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - RX FIFO full"]
#[inline (always)] pub fn twd_ctrl_rx_full (& self) -> TwdCtrlRxFullR { TwdCtrlRxFullR :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - TX FIFO empty"]
#[inline (always)] pub fn twd_ctrl_tx_empty (& self) -> TwdCtrlTxEmptyR { TwdCtrlTxEmptyR :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - TX FIFO full"]
#[inline (always)] pub fn twd_ctrl_tx_full (& self) -> TwdCtrlTxFullR { TwdCtrlTxFullR :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - current state of the SCL bus line"]
#[inline (always)] pub fn twd_ctrl_sense_scl (& self) -> TwdCtrlSenseSclR { TwdCtrlSenseSclR :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - current state of the SDA bus line"]
#[inline (always)] pub fn twd_ctrl_sense_sda (& self) -> TwdCtrlSenseSdaR { TwdCtrlSenseSdaR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - bus engine is busy (transaction in progress)"]
#[inline (always)] pub fn twd_ctrl_busy (& self) -> TwdCtrlBusyR { TwdCtrlBusyR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - TWD enable flag"]
#[inline (always)] pub fn twd_ctrl_en (& mut self) -> TwdCtrlEnW < '_ , CtrlSpec > { TwdCtrlEnW :: new (self , 0) }
#[doc = "Bit 1 - Clear RX FIFO, flag auto-clears"]
#[inline (always)] pub fn twd_ctrl_clr_rx (& mut self) -> TwdCtrlClrRxW < '_ , CtrlSpec > { TwdCtrlClrRxW :: new (self , 1) }
#[doc = "Bit 2 - Clear TX FIFO, flag auto-clears"]
#[inline (always)] pub fn twd_ctrl_clr_tx (& mut self) -> TwdCtrlClrTxW < '_ , CtrlSpec > { TwdCtrlClrTxW :: new (self , 2) }
#[doc = "Bit 3 - Bus sample clock / filter select"]
#[inline (always)] pub fn twd_ctrl_fsel (& mut self) -> TwdCtrlFselW < '_ , CtrlSpec > { TwdCtrlFselW :: new (self , 3) }
#[doc = "Bits 4:10 - Device address (7-bit)"]
#[inline (always)] pub fn twd_ctrl_dev_addr (& mut self) -> TwdCtrlDevAddrW < '_ , CtrlSpec > { TwdCtrlDevAddrW :: new (self , 4) }
#[doc = "Bit 11 - IRQ if RX FIFO data available"]
#[inline (always)] pub fn twd_ctrl_irq_rx_avail (& mut self) -> TwdCtrlIrqRxAvailW < '_ , CtrlSpec > { TwdCtrlIrqRxAvailW :: new (self , 11) }
#[doc = "Bit 12 - IRQ if RX FIFO full"]
#[inline (always)] pub fn twd_ctrl_irq_rx_full (& mut self) -> TwdCtrlIrqRxFullW < '_ , CtrlSpec > { TwdCtrlIrqRxFullW :: new (self , 12) }
#[doc = "Bit 13 - IRQ if TX FIFO empty"]
#[inline (always)] pub fn twd_ctrl_irq_tx_empty (& mut self) -> TwdCtrlIrqTxEmptyW < '_ , CtrlSpec > { TwdCtrlIrqTxEmptyW :: new (self , 13) } }
#[doc = "Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CtrlSpec ; impl crate :: RegisterSpec for CtrlSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ctrl::R`](R) reader structure"] impl crate :: Readable for CtrlSpec { }
#[doc = "`write(|w| ..)` method takes [`ctrl::W`](W) writer structure"] impl crate :: Writable for CtrlSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CTRL to value 0"] impl crate :: Resettable for CtrlSpec { } }
#[doc = "DATA (rw) register accessor: RX/TX data register\n\nYou can [`read`](crate::Reg::read) this register and get [`data::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`data::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\n<div class=\"warning\">The register is <b>modified</b> in some way after a read operation.</div>\n\nFor information about available fields see [`mod@data`] module"]
#[doc (alias = "DATA")] pub type Data = crate :: Reg < data :: DataSpec > ;
#[doc = "RX/TX data register"] pub mod data {
#[doc = "Register `DATA` reader"] pub type R = crate :: R < DataSpec > ;
#[doc = "Register `DATA` writer"] pub type W = crate :: W < DataSpec > ;
#[doc = "Field `TWI_DATA` reader - RX/TX data FIFO access"] pub type TwiDataR = crate :: FieldReader ;
#[doc = "Field `TWI_DATA` writer - RX/TX data FIFO access"] pub type TwiDataW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - RX/TX data FIFO access"]
#[inline (always)] pub fn twi_data (& self) -> TwiDataR { TwiDataR :: new ((self . bits & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - RX/TX data FIFO access"]
#[inline (always)] pub fn twi_data (& mut self) -> TwiDataW < '_ , DataSpec > { TwiDataW :: new (self , 0) } }
#[doc = "RX/TX data register\n\nYou can [`read`](crate::Reg::read) this register and get [`data::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`data::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\n<div class=\"warning\">The register is <b>modified</b> in some way after a read operation.</div>"] pub struct DataSpec ; impl crate :: RegisterSpec for DataSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`data::R`](R) reader structure"] impl crate :: Readable for DataSpec { }
#[doc = "`write(|w| ..)` method takes [`data::W`](W) writer structure"] impl crate :: Writable for DataSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DATA to value 0"] impl crate :: Resettable for DataSpec { } } }
#[doc = "True random number generator"] pub type Trng = crate :: Periph < trng :: RegisterBlock , 0xfffa_0000 > ; impl core :: fmt :: Debug for Trng { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Trng") . finish () } }
#[doc = "True random number generator"] pub mod trng {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { ctrl : Ctrl , data : Data , } impl RegisterBlock {
#[doc = "0x00 - Control and data register"]
#[inline (always)] pub const fn ctrl (& self) -> & Ctrl { & self . ctrl }
#[doc = "0x04 - Random data"]
#[inline (always)] pub const fn data (& self) -> & Data { & self . data } }
#[doc = "CTRL (rw) register accessor: Control and data register\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl`] module"]
#[doc (alias = "CTRL")] pub type Ctrl = crate :: Reg < ctrl :: CtrlSpec > ;
#[doc = "Control and data register"] pub mod ctrl {
#[doc = "Register `CTRL` reader"] pub type R = crate :: R < CtrlSpec > ;
#[doc = "Register `CTRL` writer"] pub type W = crate :: W < CtrlSpec > ;
#[doc = "Field `TRNG_CTRL_EN` reader - TRNG enable flag"] pub type TrngCtrlEnR = crate :: BitReader ;
#[doc = "Field `TRNG_CTRL_EN` writer - TRNG enable flag"] pub type TrngCtrlEnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TRNG_CTRL_FIFO_CLR` writer - Clear data FIFO when set (flag auto clears)"] pub type TrngCtrlFifoClrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TRNG_CTRL_FIFO_SIZE` reader - log2(TRNG FIFO size)"] pub type TrngCtrlFifoSizeR = crate :: FieldReader ;
#[doc = "Field `TRNG_CTRL_SIM_MODE` reader - TRNG simulation mode (PRNG!) active"] pub type TrngCtrlSimModeR = crate :: BitReader ;
#[doc = "Field `TRNG_CTRL_AVAIL` reader - Random data available"] pub type TrngCtrlAvailR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - TRNG enable flag"]
#[inline (always)] pub fn trng_ctrl_en (& self) -> TrngCtrlEnR { TrngCtrlEnR :: new ((self . bits & 1) != 0) }
#[doc = "Bits 2:5 - log2(TRNG FIFO size)"]
#[inline (always)] pub fn trng_ctrl_fifo_size (& self) -> TrngCtrlFifoSizeR { TrngCtrlFifoSizeR :: new (((self . bits >> 2) & 0x0f) as u8) }
#[doc = "Bit 6 - TRNG simulation mode (PRNG!) active"]
#[inline (always)] pub fn trng_ctrl_sim_mode (& self) -> TrngCtrlSimModeR { TrngCtrlSimModeR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Random data available"]
#[inline (always)] pub fn trng_ctrl_avail (& self) -> TrngCtrlAvailR { TrngCtrlAvailR :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - TRNG enable flag"]
#[inline (always)] pub fn trng_ctrl_en (& mut self) -> TrngCtrlEnW < '_ , CtrlSpec > { TrngCtrlEnW :: new (self , 0) }
#[doc = "Bit 1 - Clear data FIFO when set (flag auto clears)"]
#[inline (always)] pub fn trng_ctrl_fifo_clr (& mut self) -> TrngCtrlFifoClrW < '_ , CtrlSpec > { TrngCtrlFifoClrW :: new (self , 1) } }
#[doc = "Control and data register\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CtrlSpec ; impl crate :: RegisterSpec for CtrlSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ctrl::R`](R) reader structure"] impl crate :: Readable for CtrlSpec { }
#[doc = "`write(|w| ..)` method takes [`ctrl::W`](W) writer structure"] impl crate :: Writable for CtrlSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CTRL to value 0"] impl crate :: Resettable for CtrlSpec { } }
#[doc = "DATA (rw) register accessor: Random data\n\nYou can [`read`](crate::Reg::read) this register and get [`data::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`data::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\n<div class=\"warning\">The register is <b>modified</b> in some way after a read operation.</div>\n\nFor information about available fields see [`mod@data`] module"]
#[doc (alias = "DATA")] pub type Data = crate :: Reg < data :: DataSpec > ;
#[doc = "Random data"] pub mod data {
#[doc = "Register `DATA` reader"] pub type R = crate :: R < DataSpec > ;
#[doc = "Register `DATA` writer"] pub type W = crate :: W < DataSpec > ;
#[doc = "Field `TRNG_DATA` reader - Random data"] pub type TrngDataR = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - Random data"]
#[inline (always)] pub fn trng_data (& self) -> TrngDataR { TrngDataR :: new ((self . bits & 0xff) as u8) } } impl W { }
#[doc = "Random data\n\nYou can [`read`](crate::Reg::read) this register and get [`data::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`data::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\n<div class=\"warning\">The register is <b>modified</b> in some way after a read operation.</div>"] pub struct DataSpec ; impl crate :: RegisterSpec for DataSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`data::R`](R) reader structure"] impl crate :: Readable for DataSpec { }
#[doc = "`write(|w| ..)` method takes [`data::W`](W) writer structure"] impl crate :: Writable for DataSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DATA to value 0"] impl crate :: Resettable for DataSpec { } } }
#[doc = "Watchdog timer"] pub type Wdt = crate :: Periph < wdt :: RegisterBlock , 0xfffb_0000 > ; impl core :: fmt :: Debug for Wdt { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Wdt") . finish () } }
#[doc = "Watchdog timer"] pub mod wdt {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { ctrl : Ctrl , reset : Reset , } impl RegisterBlock {
#[doc = "0x00 - Control register"]
#[inline (always)] pub const fn ctrl (& self) -> & Ctrl { & self . ctrl }
#[doc = "0x04 - Watchdog reset register"]
#[inline (always)] pub const fn reset (& self) -> & Reset { & self . reset } }
#[doc = "CTRL (rw) register accessor: Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl`] module"]
#[doc (alias = "CTRL")] pub type Ctrl = crate :: Reg < ctrl :: CtrlSpec > ;
#[doc = "Control register"] pub mod ctrl {
#[doc = "Register `CTRL` reader"] pub type R = crate :: R < CtrlSpec > ;
#[doc = "Register `CTRL` writer"] pub type W = crate :: W < CtrlSpec > ;
#[doc = "Field `WDT_CTRL_EN` reader - WDT enable flag"] pub type WdtCtrlEnR = crate :: BitReader ;
#[doc = "Field `WDT_CTRL_EN` writer - WDT enable flag"] pub type WdtCtrlEnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WDT_CTRL_LOCK` reader - Lock write access to control register, clears on reset only"] pub type WdtCtrlLockR = crate :: BitReader ;
#[doc = "Field `WDT_CTRL_LOCK` writer - Lock write access to control register, clears on reset only"] pub type WdtCtrlLockW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WDT_CTRL_RCAUSE` reader - Cause of last system reset: 0=external reset, 1=OCD reset, 2=WDT reset, 3=WDT access violation"] pub type WdtCtrlRcauseR = crate :: FieldReader ;
#[doc = "Field `WDT_CTRL_TIMEOUT` reader - Timeout value"] pub type WdtCtrlTimeoutR = crate :: FieldReader < u32 > ;
#[doc = "Field `WDT_CTRL_TIMEOUT` writer - Timeout value"] pub type WdtCtrlTimeoutW < 'a , REG > = crate :: FieldWriter < 'a , REG , 24 , u32 > ; impl R {
#[doc = "Bit 0 - WDT enable flag"]
#[inline (always)] pub fn wdt_ctrl_en (& self) -> WdtCtrlEnR { WdtCtrlEnR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Lock write access to control register, clears on reset only"]
#[inline (always)] pub fn wdt_ctrl_lock (& self) -> WdtCtrlLockR { WdtCtrlLockR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bits 2:3 - Cause of last system reset: 0=external reset, 1=OCD reset, 2=WDT reset, 3=WDT access violation"]
#[inline (always)] pub fn wdt_ctrl_rcause (& self) -> WdtCtrlRcauseR { WdtCtrlRcauseR :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 8:31 - Timeout value"]
#[inline (always)] pub fn wdt_ctrl_timeout (& self) -> WdtCtrlTimeoutR { WdtCtrlTimeoutR :: new ((self . bits >> 8) & 0x00ff_ffff) } } impl W {
#[doc = "Bit 0 - WDT enable flag"]
#[inline (always)] pub fn wdt_ctrl_en (& mut self) -> WdtCtrlEnW < '_ , CtrlSpec > { WdtCtrlEnW :: new (self , 0) }
#[doc = "Bit 1 - Lock write access to control register, clears on reset only"]
#[inline (always)] pub fn wdt_ctrl_lock (& mut self) -> WdtCtrlLockW < '_ , CtrlSpec > { WdtCtrlLockW :: new (self , 1) }
#[doc = "Bits 8:31 - Timeout value"]
#[inline (always)] pub fn wdt_ctrl_timeout (& mut self) -> WdtCtrlTimeoutW < '_ , CtrlSpec > { WdtCtrlTimeoutW :: new (self , 8) } }
#[doc = "Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CtrlSpec ; impl crate :: RegisterSpec for CtrlSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ctrl::R`](R) reader structure"] impl crate :: Readable for CtrlSpec { }
#[doc = "`write(|w| ..)` method takes [`ctrl::W`](W) writer structure"] impl crate :: Writable for CtrlSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CTRL to value 0"] impl crate :: Resettable for CtrlSpec { } }
#[doc = "RESET (rw) register accessor: Watchdog reset register\n\nYou can [`read`](crate::Reg::read) this register and get [`reset::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reset::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reset`] module"]
#[doc (alias = "RESET")] pub type Reset = crate :: Reg < reset :: ResetSpec > ;
#[doc = "Watchdog reset register"] pub mod reset {
#[doc = "Register `RESET` reader"] pub type R = crate :: R < ResetSpec > ;
#[doc = "Register `RESET` writer"] pub type W = crate :: W < ResetSpec > ;
#[doc = "Field `WDT_RESET` writer - Write password to reset/feed the watchdog (0x709D1AB3)"] pub type WdtResetW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl W {
#[doc = "Bits 0:31 - Write password to reset/feed the watchdog (0x709D1AB3)"]
#[inline (always)] pub fn wdt_reset (& mut self) -> WdtResetW < '_ , ResetSpec > { WdtResetW :: new (self , 0) } }
#[doc = "Watchdog reset register\n\nYou can [`read`](crate::Reg::read) this register and get [`reset::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reset::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ResetSpec ; impl crate :: RegisterSpec for ResetSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`reset::R`](R) reader structure"] impl crate :: Readable for ResetSpec { }
#[doc = "`write(|w| ..)` method takes [`reset::W`](W) writer structure"] impl crate :: Writable for ResetSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets RESET to value 0"] impl crate :: Resettable for ResetSpec { } } }
#[doc = "General purpose input/output port"] pub type Gpio = crate :: Periph < gpio :: RegisterBlock , 0xfffc_0000 > ; impl core :: fmt :: Debug for Gpio { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gpio") . finish () } }
#[doc = "General purpose input/output port"] pub mod gpio {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { port_in : PortIn , port_out : PortOut , _reserved2 : [u8 ; 0x08] , irq_type : IrqType , irq_polarity : IrqPolarity , irq_enable : IrqEnable , irq_pending : IrqPending , } impl RegisterBlock {
#[doc = "0x00 - Parallel input port"]
#[inline (always)] pub const fn port_in (& self) -> & PortIn { & self . port_in }
#[doc = "0x04 - Parallel output port"]
#[inline (always)] pub const fn port_out (& self) -> & PortOut { & self . port_out }
#[doc = "0x10 - Interrupt trigger type (level/edge) for each input pin"]
#[inline (always)] pub const fn irq_type (& self) -> & IrqType { & self . irq_type }
#[doc = "0x14 - Interrupt trigger polarity (rising/falling or high/low) for each input pin"]
#[inline (always)] pub const fn irq_polarity (& self) -> & IrqPolarity { & self . irq_polarity }
#[doc = "0x18 - Interrupt enable for each input pin"]
#[inline (always)] pub const fn irq_enable (& self) -> & IrqEnable { & self . irq_enable }
#[doc = "0x1c - Interrupt pending for each input pin; cleared by writing zero"]
#[inline (always)] pub const fn irq_pending (& self) -> & IrqPending { & self . irq_pending } }
#[doc = "PORT_IN (r) register accessor: Parallel input port\n\nYou can [`read`](crate::Reg::read) this register and get [`port_in::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@port_in`] module"]
#[doc (alias = "PORT_IN")] pub type PortIn = crate :: Reg < port_in :: PortInSpec > ;
#[doc = "Parallel input port"] pub mod port_in {
#[doc = "Register `PORT_IN` reader"] pub type R = crate :: R < PortInSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } }
#[doc = "Parallel input port\n\nYou can [`read`](crate::Reg::read) this register and get [`port_in::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PortInSpec ; impl crate :: RegisterSpec for PortInSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`port_in::R`](R) reader structure"] impl crate :: Readable for PortInSpec { }
#[doc = "`reset()` method sets PORT_IN to value 0"] impl crate :: Resettable for PortInSpec { } }
#[doc = "PORT_OUT (rw) register accessor: Parallel output port\n\nYou can [`read`](crate::Reg::read) this register and get [`port_out::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`port_out::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@port_out`] module"]
#[doc (alias = "PORT_OUT")] pub type PortOut = crate :: Reg < port_out :: PortOutSpec > ;
#[doc = "Parallel output port"] pub mod port_out {
#[doc = "Register `PORT_OUT` reader"] pub type R = crate :: R < PortOutSpec > ;
#[doc = "Register `PORT_OUT` writer"] pub type W = crate :: W < PortOutSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "Parallel output port\n\nYou can [`read`](crate::Reg::read) this register and get [`port_out::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`port_out::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PortOutSpec ; impl crate :: RegisterSpec for PortOutSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`port_out::R`](R) reader structure"] impl crate :: Readable for PortOutSpec { }
#[doc = "`write(|w| ..)` method takes [`port_out::W`](W) writer structure"] impl crate :: Writable for PortOutSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PORT_OUT to value 0"] impl crate :: Resettable for PortOutSpec { } }
#[doc = "IRQ_TYPE (rw) register accessor: Interrupt trigger type (level/edge) for each input pin\n\nYou can [`read`](crate::Reg::read) this register and get [`irq_type::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`irq_type::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@irq_type`] module"]
#[doc (alias = "IRQ_TYPE")] pub type IrqType = crate :: Reg < irq_type :: IrqTypeSpec > ;
#[doc = "Interrupt trigger type (level/edge) for each input pin"] pub mod irq_type {
#[doc = "Register `IRQ_TYPE` reader"] pub type R = crate :: R < IrqTypeSpec > ;
#[doc = "Register `IRQ_TYPE` writer"] pub type W = crate :: W < IrqTypeSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "Interrupt trigger type (level/edge) for each input pin\n\nYou can [`read`](crate::Reg::read) this register and get [`irq_type::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`irq_type::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IrqTypeSpec ; impl crate :: RegisterSpec for IrqTypeSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`irq_type::R`](R) reader structure"] impl crate :: Readable for IrqTypeSpec { }
#[doc = "`write(|w| ..)` method takes [`irq_type::W`](W) writer structure"] impl crate :: Writable for IrqTypeSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IRQ_TYPE to value 0"] impl crate :: Resettable for IrqTypeSpec { } }
#[doc = "IRQ_POLARITY (rw) register accessor: Interrupt trigger polarity (rising/falling or high/low) for each input pin\n\nYou can [`read`](crate::Reg::read) this register and get [`irq_polarity::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`irq_polarity::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@irq_polarity`] module"]
#[doc (alias = "IRQ_POLARITY")] pub type IrqPolarity = crate :: Reg < irq_polarity :: IrqPolaritySpec > ;
#[doc = "Interrupt trigger polarity (rising/falling or high/low) for each input pin"] pub mod irq_polarity {
#[doc = "Register `IRQ_POLARITY` reader"] pub type R = crate :: R < IrqPolaritySpec > ;
#[doc = "Register `IRQ_POLARITY` writer"] pub type W = crate :: W < IrqPolaritySpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "Interrupt trigger polarity (rising/falling or high/low) for each input pin\n\nYou can [`read`](crate::Reg::read) this register and get [`irq_polarity::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`irq_polarity::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IrqPolaritySpec ; impl crate :: RegisterSpec for IrqPolaritySpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`irq_polarity::R`](R) reader structure"] impl crate :: Readable for IrqPolaritySpec { }
#[doc = "`write(|w| ..)` method takes [`irq_polarity::W`](W) writer structure"] impl crate :: Writable for IrqPolaritySpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IRQ_POLARITY to value 0"] impl crate :: Resettable for IrqPolaritySpec { } }
#[doc = "IRQ_ENABLE (rw) register accessor: Interrupt enable for each input pin\n\nYou can [`read`](crate::Reg::read) this register and get [`irq_enable::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`irq_enable::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@irq_enable`] module"]
#[doc (alias = "IRQ_ENABLE")] pub type IrqEnable = crate :: Reg < irq_enable :: IrqEnableSpec > ;
#[doc = "Interrupt enable for each input pin"] pub mod irq_enable {
#[doc = "Register `IRQ_ENABLE` reader"] pub type R = crate :: R < IrqEnableSpec > ;
#[doc = "Register `IRQ_ENABLE` writer"] pub type W = crate :: W < IrqEnableSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "Interrupt enable for each input pin\n\nYou can [`read`](crate::Reg::read) this register and get [`irq_enable::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`irq_enable::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IrqEnableSpec ; impl crate :: RegisterSpec for IrqEnableSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`irq_enable::R`](R) reader structure"] impl crate :: Readable for IrqEnableSpec { }
#[doc = "`write(|w| ..)` method takes [`irq_enable::W`](W) writer structure"] impl crate :: Writable for IrqEnableSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IRQ_ENABLE to value 0"] impl crate :: Resettable for IrqEnableSpec { } }
#[doc = "IRQ_PENDING (rw) register accessor: Interrupt pending for each input pin; cleared by writing zero\n\nYou can [`read`](crate::Reg::read) this register and get [`irq_pending::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`irq_pending::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@irq_pending`] module"]
#[doc (alias = "IRQ_PENDING")] pub type IrqPending = crate :: Reg < irq_pending :: IrqPendingSpec > ;
#[doc = "Interrupt pending for each input pin; cleared by writing zero"] pub mod irq_pending {
#[doc = "Register `IRQ_PENDING` reader"] pub type R = crate :: R < IrqPendingSpec > ;
#[doc = "Register `IRQ_PENDING` writer"] pub type W = crate :: W < IrqPendingSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "Interrupt pending for each input pin; cleared by writing zero\n\nYou can [`read`](crate::Reg::read) this register and get [`irq_pending::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`irq_pending::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IrqPendingSpec ; impl crate :: RegisterSpec for IrqPendingSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`irq_pending::R`](R) reader structure"] impl crate :: Readable for IrqPendingSpec { }
#[doc = "`write(|w| ..)` method takes [`irq_pending::W`](W) writer structure"] impl crate :: Writable for IrqPendingSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IRQ_PENDING to value 0"] impl crate :: Resettable for IrqPendingSpec { } } }
#[doc = "Smart LED hardware interface"] pub type Neoled = crate :: Periph < neoled :: RegisterBlock , 0xfffd_0000 > ; impl core :: fmt :: Debug for Neoled { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Neoled") . finish () } }
#[doc = "Smart LED hardware interface"] pub mod neoled {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { ctrl : Ctrl , data24 : Data24 , data32 : Data32 , strobe : Strobe , } impl RegisterBlock {
#[doc = "0x00 - Control register"]
#[inline (always)] pub const fn ctrl (& self) -> & Ctrl { & self . ctrl }
#[doc = "0x04 - Send 24-bit data"]
#[inline (always)] pub const fn data24 (& self) -> & Data24 { & self . data24 }
#[doc = "0x08 - Send 32-bit data"]
#[inline (always)] pub const fn data32 (& self) -> & Data32 { & self . data32 }
#[doc = "0x0c - Write any value to send STROBE command"]
#[inline (always)] pub const fn strobe (& self) -> & Strobe { & self . strobe } }
#[doc = "CTRL (rw) register accessor: Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl`] module"]
#[doc (alias = "CTRL")] pub type Ctrl = crate :: Reg < ctrl :: CtrlSpec > ;
#[doc = "Control register"] pub mod ctrl {
#[doc = "Register `CTRL` reader"] pub type R = crate :: R < CtrlSpec > ;
#[doc = "Register `CTRL` writer"] pub type W = crate :: W < CtrlSpec > ;
#[doc = "Field `NEOLED_CTRL_EN` reader - NEOLED enable flag"] pub type NeoledCtrlEnR = crate :: BitReader ;
#[doc = "Field `NEOLED_CTRL_EN` writer - NEOLED enable flag"] pub type NeoledCtrlEnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NEOLED_CTRL_PRSC` reader - Clock prescaler select"] pub type NeoledCtrlPrscR = crate :: FieldReader ;
#[doc = "Field `NEOLED_CTRL_PRSC` writer - Clock prescaler select"] pub type NeoledCtrlPrscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `NEOLED_CTRL_T_TOT` reader - pulse-clock ticks per total period bit"] pub type NeoledCtrlTTotR = crate :: FieldReader ;
#[doc = "Field `NEOLED_CTRL_T_TOT` writer - pulse-clock ticks per total period bit"] pub type NeoledCtrlTTotW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `NEOLED_CTRL_T_0H` reader - pulse-clock ticks per ZERO high-time"] pub type NeoledCtrlT0hR = crate :: FieldReader ;
#[doc = "Field `NEOLED_CTRL_T_0H` writer - pulse-clock ticks per ZERO high-time"] pub type NeoledCtrlT0hW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `NEOLED_CTRL_T_1H` reader - pulse-clock ticks per ONE high-time"] pub type NeoledCtrlT1hR = crate :: FieldReader ;
#[doc = "Field `NEOLED_CTRL_T_1H` writer - pulse-clock ticks per ONE high-time"] pub type NeoledCtrlT1hW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `NEOLED_CTRL_FIFO` reader - log2(TX FIFO size)"] pub type NeoledCtrlFifoR = crate :: FieldReader ;
#[doc = "Field `NEOLED_CTRL_TX_EMPTY` reader - TX FIFO is empty"] pub type NeoledCtrlTxEmptyR = crate :: BitReader ;
#[doc = "Field `NEOLED_CTRL_TX_FULL` reader - TX FIFO is full"] pub type NeoledCtrlTxFullR = crate :: BitReader ;
#[doc = "Field `NEOLED_CTRL_TX_BUSY` reader - busy flag"] pub type NeoledCtrlTxBusyR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - NEOLED enable flag"]
#[inline (always)] pub fn neoled_ctrl_en (& self) -> NeoledCtrlEnR { NeoledCtrlEnR :: new ((self . bits & 1) != 0) }
#[doc = "Bits 1:3 - Clock prescaler select"]
#[inline (always)] pub fn neoled_ctrl_prsc (& self) -> NeoledCtrlPrscR { NeoledCtrlPrscR :: new (((self . bits >> 1) & 7) as u8) }
#[doc = "Bits 4:8 - pulse-clock ticks per total period bit"]
#[inline (always)] pub fn neoled_ctrl_t_tot (& self) -> NeoledCtrlTTotR { NeoledCtrlTTotR :: new (((self . bits >> 4) & 0x1f) as u8) }
#[doc = "Bits 9:13 - pulse-clock ticks per ZERO high-time"]
#[inline (always)] pub fn neoled_ctrl_t_0h (& self) -> NeoledCtrlT0hR { NeoledCtrlT0hR :: new (((self . bits >> 9) & 0x1f) as u8) }
#[doc = "Bits 14:18 - pulse-clock ticks per ONE high-time"]
#[inline (always)] pub fn neoled_ctrl_t_1h (& self) -> NeoledCtrlT1hR { NeoledCtrlT1hR :: new (((self . bits >> 14) & 0x1f) as u8) }
#[doc = "Bits 25:28 - log2(TX FIFO size)"]
#[inline (always)] pub fn neoled_ctrl_fifo (& self) -> NeoledCtrlFifoR { NeoledCtrlFifoR :: new (((self . bits >> 25) & 0x0f) as u8) }
#[doc = "Bit 29 - TX FIFO is empty"]
#[inline (always)] pub fn neoled_ctrl_tx_empty (& self) -> NeoledCtrlTxEmptyR { NeoledCtrlTxEmptyR :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - TX FIFO is full"]
#[inline (always)] pub fn neoled_ctrl_tx_full (& self) -> NeoledCtrlTxFullR { NeoledCtrlTxFullR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - busy flag"]
#[inline (always)] pub fn neoled_ctrl_tx_busy (& self) -> NeoledCtrlTxBusyR { NeoledCtrlTxBusyR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - NEOLED enable flag"]
#[inline (always)] pub fn neoled_ctrl_en (& mut self) -> NeoledCtrlEnW < '_ , CtrlSpec > { NeoledCtrlEnW :: new (self , 0) }
#[doc = "Bits 1:3 - Clock prescaler select"]
#[inline (always)] pub fn neoled_ctrl_prsc (& mut self) -> NeoledCtrlPrscW < '_ , CtrlSpec > { NeoledCtrlPrscW :: new (self , 1) }
#[doc = "Bits 4:8 - pulse-clock ticks per total period bit"]
#[inline (always)] pub fn neoled_ctrl_t_tot (& mut self) -> NeoledCtrlTTotW < '_ , CtrlSpec > { NeoledCtrlTTotW :: new (self , 4) }
#[doc = "Bits 9:13 - pulse-clock ticks per ZERO high-time"]
#[inline (always)] pub fn neoled_ctrl_t_0h (& mut self) -> NeoledCtrlT0hW < '_ , CtrlSpec > { NeoledCtrlT0hW :: new (self , 9) }
#[doc = "Bits 14:18 - pulse-clock ticks per ONE high-time"]
#[inline (always)] pub fn neoled_ctrl_t_1h (& mut self) -> NeoledCtrlT1hW < '_ , CtrlSpec > { NeoledCtrlT1hW :: new (self , 14) } }
#[doc = "Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CtrlSpec ; impl crate :: RegisterSpec for CtrlSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ctrl::R`](R) reader structure"] impl crate :: Readable for CtrlSpec { }
#[doc = "`write(|w| ..)` method takes [`ctrl::W`](W) writer structure"] impl crate :: Writable for CtrlSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CTRL to value 0"] impl crate :: Resettable for CtrlSpec { } }
#[doc = "DATA24 (w) register accessor: Send 24-bit data\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`data24::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@data24`] module"]
#[doc (alias = "DATA24")] pub type Data24 = crate :: Reg < data24 :: Data24Spec > ;
#[doc = "Send 24-bit data"] pub mod data24 {
#[doc = "Register `DATA24` writer"] pub type W = crate :: W < Data24Spec > ; impl core :: fmt :: Debug for crate :: generic :: Reg < Data24Spec > { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { write ! (f , "(not readable)") } } impl W { }
#[doc = "Send 24-bit data\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`data24::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Data24Spec ; impl crate :: RegisterSpec for Data24Spec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`data24::W`](W) writer structure"] impl crate :: Writable for Data24Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DATA24 to value 0"] impl crate :: Resettable for Data24Spec { } }
#[doc = "DATA32 (w) register accessor: Send 32-bit data\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`data32::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@data32`] module"]
#[doc (alias = "DATA32")] pub type Data32 = crate :: Reg < data32 :: Data32Spec > ;
#[doc = "Send 32-bit data"] pub mod data32 {
#[doc = "Register `DATA32` writer"] pub type W = crate :: W < Data32Spec > ; impl core :: fmt :: Debug for crate :: generic :: Reg < Data32Spec > { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { write ! (f , "(not readable)") } } impl W { }
#[doc = "Send 32-bit data\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`data32::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Data32Spec ; impl crate :: RegisterSpec for Data32Spec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`data32::W`](W) writer structure"] impl crate :: Writable for Data32Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DATA32 to value 0"] impl crate :: Resettable for Data32Spec { } }
#[doc = "STROBE (w) register accessor: Write any value to send STROBE command\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`strobe::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@strobe`] module"]
#[doc (alias = "STROBE")] pub type Strobe = crate :: Reg < strobe :: StrobeSpec > ;
#[doc = "Write any value to send STROBE command"] pub mod strobe {
#[doc = "Register `STROBE` writer"] pub type W = crate :: W < StrobeSpec > ; impl core :: fmt :: Debug for crate :: generic :: Reg < StrobeSpec > { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { write ! (f , "(not readable)") } } impl W { }
#[doc = "Write any value to send STROBE command\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`strobe::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct StrobeSpec ; impl crate :: RegisterSpec for StrobeSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`strobe::W`](W) writer structure"] impl crate :: Writable for StrobeSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets STROBE to value 0"] impl crate :: Resettable for StrobeSpec { } } }
#[doc = "Execution Trace Buffer"] pub type Tracer = crate :: Periph < tracer :: RegisterBlock , 0xfff3_0000 > ; impl core :: fmt :: Debug for Tracer { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tracer") . finish () } }
#[doc = "Execution Trace Buffer"] pub mod tracer {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { ctrl : Ctrl , stop_addr : StopAddr , delta_src : DeltaSrc , delta_dst : DeltaDst , } impl RegisterBlock {
#[doc = "0x00 - Control and status register"]
#[inline (always)] pub const fn ctrl (& self) -> & Ctrl { & self . ctrl }
#[doc = "0x04 - Stop tracing when reaching this address, set to all-zero to disable auto-stopping"]
#[inline (always)] pub const fn stop_addr (& self) -> & StopAddr { & self . stop_addr }
#[doc = "0x08 - Trace data: delta source address + trap-entry bit"]
#[inline (always)] pub const fn delta_src (& self) -> & DeltaSrc { & self . delta_src }
#[doc = "0x0c - Trace data: delta destination address + frist-packet bit"]
#[inline (always)] pub const fn delta_dst (& self) -> & DeltaDst { & self . delta_dst } }
#[doc = "CTRL (rw) register accessor: Control and status register\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl`] module"]
#[doc (alias = "CTRL")] pub type Ctrl = crate :: Reg < ctrl :: CtrlSpec > ;
#[doc = "Control and status register"] pub mod ctrl {
#[doc = "Register `CTRL` reader"] pub type R = crate :: R < CtrlSpec > ;
#[doc = "Register `CTRL` writer"] pub type W = crate :: W < CtrlSpec > ;
#[doc = "Field `TRACER_CTRL_EN` reader - TRACER enable, reset module when 0"] pub type TracerCtrlEnR = crate :: BitReader ;
#[doc = "Field `TRACER_CTRL_EN` writer - TRACER enable, reset module when 0"] pub type TracerCtrlEnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TRACER_CTRL_HSEL` reader - Hart select for tracing"] pub type TracerCtrlHselR = crate :: BitReader ;
#[doc = "Field `TRACER_CTRL_HSEL` writer - Hart select for tracing"] pub type TracerCtrlHselW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TRACER_CTRL_START` writer - Start tracing, flag always reads as zero"] pub type TracerCtrlStartW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TRACER_CTRL_STOP` writer - Manually stop tracing, flag always reads as zero"] pub type TracerCtrlStopW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TRACER_CTRL_RUN` reader - Tracing in progress when set"] pub type TracerCtrlRunR = crate :: BitReader ;
#[doc = "Field `TRACER_CTRL_AVAIL` reader - Trace data available when set"] pub type TracerCtrlAvailR = crate :: BitReader ;
#[doc = "Field `TRACER_CTRL_IRQ_CLR` writer - Clear pending interrupt when writing 1"] pub type TracerCtrlIrqClrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TRACER_CTRL_TBM` reader - log2 of trace buffer depth"] pub type TracerCtrlTbmR = crate :: FieldReader ; impl R {
#[doc = "Bit 0 - TRACER enable, reset module when 0"]
#[inline (always)] pub fn tracer_ctrl_en (& self) -> TracerCtrlEnR { TracerCtrlEnR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Hart select for tracing"]
#[inline (always)] pub fn tracer_ctrl_hsel (& self) -> TracerCtrlHselR { TracerCtrlHselR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 4 - Tracing in progress when set"]
#[inline (always)] pub fn tracer_ctrl_run (& self) -> TracerCtrlRunR { TracerCtrlRunR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Trace data available when set"]
#[inline (always)] pub fn tracer_ctrl_avail (& self) -> TracerCtrlAvailR { TracerCtrlAvailR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bits 7:10 - log2 of trace buffer depth"]
#[inline (always)] pub fn tracer_ctrl_tbm (& self) -> TracerCtrlTbmR { TracerCtrlTbmR :: new (((self . bits >> 7) & 0x0f) as u8) } } impl W {
#[doc = "Bit 0 - TRACER enable, reset module when 0"]
#[inline (always)] pub fn tracer_ctrl_en (& mut self) -> TracerCtrlEnW < '_ , CtrlSpec > { TracerCtrlEnW :: new (self , 0) }
#[doc = "Bit 1 - Hart select for tracing"]
#[inline (always)] pub fn tracer_ctrl_hsel (& mut self) -> TracerCtrlHselW < '_ , CtrlSpec > { TracerCtrlHselW :: new (self , 1) }
#[doc = "Bit 2 - Start tracing, flag always reads as zero"]
#[inline (always)] pub fn tracer_ctrl_start (& mut self) -> TracerCtrlStartW < '_ , CtrlSpec > { TracerCtrlStartW :: new (self , 2) }
#[doc = "Bit 3 - Manually stop tracing, flag always reads as zero"]
#[inline (always)] pub fn tracer_ctrl_stop (& mut self) -> TracerCtrlStopW < '_ , CtrlSpec > { TracerCtrlStopW :: new (self , 3) }
#[doc = "Bit 6 - Clear pending interrupt when writing 1"]
#[inline (always)] pub fn tracer_ctrl_irq_clr (& mut self) -> TracerCtrlIrqClrW < '_ , CtrlSpec > { TracerCtrlIrqClrW :: new (self , 6) } }
#[doc = "Control and status register\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CtrlSpec ; impl crate :: RegisterSpec for CtrlSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ctrl::R`](R) reader structure"] impl crate :: Readable for CtrlSpec { }
#[doc = "`write(|w| ..)` method takes [`ctrl::W`](W) writer structure"] impl crate :: Writable for CtrlSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CTRL to value 0"] impl crate :: Resettable for CtrlSpec { } }
#[doc = "STOP_ADDR (rw) register accessor: Stop tracing when reaching this address, set to all-zero to disable auto-stopping\n\nYou can [`read`](crate::Reg::read) this register and get [`stop_addr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`stop_addr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@stop_addr`] module"]
#[doc (alias = "STOP_ADDR")] pub type StopAddr = crate :: Reg < stop_addr :: StopAddrSpec > ;
#[doc = "Stop tracing when reaching this address, set to all-zero to disable auto-stopping"] pub mod stop_addr {
#[doc = "Register `STOP_ADDR` reader"] pub type R = crate :: R < StopAddrSpec > ;
#[doc = "Register `STOP_ADDR` writer"] pub type W = crate :: W < StopAddrSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "Stop tracing when reaching this address, set to all-zero to disable auto-stopping\n\nYou can [`read`](crate::Reg::read) this register and get [`stop_addr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`stop_addr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct StopAddrSpec ; impl crate :: RegisterSpec for StopAddrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`stop_addr::R`](R) reader structure"] impl crate :: Readable for StopAddrSpec { }
#[doc = "`write(|w| ..)` method takes [`stop_addr::W`](W) writer structure"] impl crate :: Writable for StopAddrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets STOP_ADDR to value 0"] impl crate :: Resettable for StopAddrSpec { } }
#[doc = "DELTA_SRC (r) register accessor: Trace data: delta source address + trap-entry bit\n\nYou can [`read`](crate::Reg::read) this register and get [`delta_src::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@delta_src`] module"]
#[doc (alias = "DELTA_SRC")] pub type DeltaSrc = crate :: Reg < delta_src :: DeltaSrcSpec > ;
#[doc = "Trace data: delta source address + trap-entry bit"] pub mod delta_src {
#[doc = "Register `DELTA_SRC` reader"] pub type R = crate :: R < DeltaSrcSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } }
#[doc = "Trace data: delta source address + trap-entry bit\n\nYou can [`read`](crate::Reg::read) this register and get [`delta_src::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DeltaSrcSpec ; impl crate :: RegisterSpec for DeltaSrcSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`delta_src::R`](R) reader structure"] impl crate :: Readable for DeltaSrcSpec { }
#[doc = "`reset()` method sets DELTA_SRC to value 0"] impl crate :: Resettable for DeltaSrcSpec { } }
#[doc = "DELTA_DST (r) register accessor: Trace data: delta destination address + frist-packet bit\n\nYou can [`read`](crate::Reg::read) this register and get [`delta_dst::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@delta_dst`] module"]
#[doc (alias = "DELTA_DST")] pub type DeltaDst = crate :: Reg < delta_dst :: DeltaDstSpec > ;
#[doc = "Trace data: delta destination address + frist-packet bit"] pub mod delta_dst {
#[doc = "Register `DELTA_DST` reader"] pub type R = crate :: R < DeltaDstSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } }
#[doc = "Trace data: delta destination address + frist-packet bit\n\nYou can [`read`](crate::Reg::read) this register and get [`delta_dst::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DeltaDstSpec ; impl crate :: RegisterSpec for DeltaDstSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`delta_dst::R`](R) reader structure"] impl crate :: Readable for DeltaDstSpec { }
#[doc = "`reset()` method sets DELTA_DST to value 0"] impl crate :: Resettable for DeltaDstSpec { } } }
#[doc = "System configuration information memory"] pub type Sysinfo = crate :: Periph < sysinfo :: RegisterBlock , 0xfffe_0000 > ; impl core :: fmt :: Debug for Sysinfo { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Sysinfo") . finish () } }
#[doc = "System configuration information memory"] pub mod sysinfo {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { clk : Clk , mem : Mem , soc : Soc , cache : Cache , } impl RegisterBlock {
#[doc = "0x00 - Processor clock speed in Hz"]
#[inline (always)] pub const fn clk (& self) -> & Clk { & self . clk }
#[doc = "0x04 - Miscellaneous system configurations"]
#[inline (always)] pub const fn mem (& self) -> & Mem { & self . mem }
#[doc = "0x08 - SoC configuration"]
#[inline (always)] pub const fn soc (& self) -> & Soc { & self . soc }
#[doc = "0x0c - Cache configuration"]
#[inline (always)] pub const fn cache (& self) -> & Cache { & self . cache } }
#[doc = "CLK (rw) register accessor: Processor clock speed in Hz\n\nYou can [`read`](crate::Reg::read) this register and get [`clk::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clk::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@clk`] module"]
#[doc (alias = "CLK")] pub type Clk = crate :: Reg < clk :: ClkSpec > ;
#[doc = "Processor clock speed in Hz"] pub mod clk {
#[doc = "Register `CLK` reader"] pub type R = crate :: R < ClkSpec > ;
#[doc = "Register `CLK` writer"] pub type W = crate :: W < ClkSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "Processor clock speed in Hz\n\nYou can [`read`](crate::Reg::read) this register and get [`clk::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clk::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ClkSpec ; impl crate :: RegisterSpec for ClkSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`clk::R`](R) reader structure"] impl crate :: Readable for ClkSpec { }
#[doc = "`write(|w| ..)` method takes [`clk::W`](W) writer structure"] impl crate :: Writable for ClkSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CLK to value 0"] impl crate :: Resettable for ClkSpec { } }
#[doc = "MEM (r) register accessor: Miscellaneous system configurations\n\nYou can [`read`](crate::Reg::read) this register and get [`mem::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mem`] module"]
#[doc (alias = "MEM")] pub type Mem = crate :: Reg < mem :: MemSpec > ;
#[doc = "Miscellaneous system configurations"] pub mod mem {
#[doc = "Register `MEM` reader"] pub type R = crate :: R < MemSpec > ;
#[doc = "Field `SYSINFO_MISC_IMEM` reader - log2(IMEM size in bytes)"] pub type SysinfoMiscImemR = crate :: FieldReader ;
#[doc = "Field `SYSINFO_MISC_DMEM` reader - log2(DMEM size in bytes)"] pub type SysinfoMiscDmemR = crate :: FieldReader ;
#[doc = "Field `SYSINFO_MISC_HART` reader - Number of physical CPU cores"] pub type SysinfoMiscHartR = crate :: FieldReader ;
#[doc = "Field `SYSINFO_MISC_BOOT` reader - Boot mode configuration select"] pub type SysinfoMiscBootR = crate :: FieldReader ;
#[doc = "Field `SYSINFO_MISC_BTMO` reader - log2(bus timeout cycles)"] pub type SysinfoMiscBtmoR = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - log2(IMEM size in bytes)"]
#[inline (always)] pub fn sysinfo_misc_imem (& self) -> SysinfoMiscImemR { SysinfoMiscImemR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:15 - log2(DMEM size in bytes)"]
#[inline (always)] pub fn sysinfo_misc_dmem (& self) -> SysinfoMiscDmemR { SysinfoMiscDmemR :: new (((self . bits >> 8) & 0xff) as u8) }
#[doc = "Bits 16:19 - Number of physical CPU cores"]
#[inline (always)] pub fn sysinfo_misc_hart (& self) -> SysinfoMiscHartR { SysinfoMiscHartR :: new (((self . bits >> 16) & 0x0f) as u8) }
#[doc = "Bits 20:23 - Boot mode configuration select"]
#[inline (always)] pub fn sysinfo_misc_boot (& self) -> SysinfoMiscBootR { SysinfoMiscBootR :: new (((self . bits >> 20) & 0x0f) as u8) }
#[doc = "Bits 24:31 - log2(bus timeout cycles)"]
#[inline (always)] pub fn sysinfo_misc_btmo (& self) -> SysinfoMiscBtmoR { SysinfoMiscBtmoR :: new (((self . bits >> 24) & 0xff) as u8) } }
#[doc = "Miscellaneous system configurations\n\nYou can [`read`](crate::Reg::read) this register and get [`mem::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MemSpec ; impl crate :: RegisterSpec for MemSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`mem::R`](R) reader structure"] impl crate :: Readable for MemSpec { }
#[doc = "`reset()` method sets MEM to value 0"] impl crate :: Resettable for MemSpec { } }
#[doc = "SOC (r) register accessor: SoC configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`soc::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@soc`] module"]
#[doc (alias = "SOC")] pub type Soc = crate :: Reg < soc :: SocSpec > ;
#[doc = "SoC configuration"] pub mod soc {
#[doc = "Register `SOC` reader"] pub type R = crate :: R < SocSpec > ;
#[doc = "Field `SYSINFO_SOC_BOOTLOADER` reader - Bootloader implemented"] pub type SysinfoSocBootloaderR = crate :: BitReader ;
#[doc = "Field `SYSINFO_SOC_XBUS` reader - External bus interface implemented"] pub type SysinfoSocXbusR = crate :: BitReader ;
#[doc = "Field `SYSINFO_SOC_IMEM` reader - Processor-internal instruction memory implemented"] pub type SysinfoSocImemR = crate :: BitReader ;
#[doc = "Field `SYSINFO_SOC_DMEM` reader - Processor-internal data memory implemented"] pub type SysinfoSocDmemR = crate :: BitReader ;
#[doc = "Field `SYSINFO_SOC_OCD` reader - On-chip debugger implemented"] pub type SysinfoSocOcdR = crate :: BitReader ;
#[doc = "Field `SYSINFO_SOC_ICACHE` reader - Processor-internal instruction cache implemented"] pub type SysinfoSocIcacheR = crate :: BitReader ;
#[doc = "Field `SYSINFO_SOC_DCACHE` reader - Processor-internal data cache implemented"] pub type SysinfoSocDcacheR = crate :: BitReader ;
#[doc = "Field `SYSINFO_SOC_OCD_AUTH` reader - On-chip debugger authentication implemented"] pub type SysinfoSocOcdAuthR = crate :: BitReader ;
#[doc = "Field `SYSINFO_SOC_IMEM_ROM` reader - Processor-internal instruction memory implemented as pre-initialized ROM"] pub type SysinfoSocImemRomR = crate :: BitReader ;
#[doc = "Field `SYSINFO_SOC_IO_TWD` reader - Two-wire device implemented"] pub type SysinfoSocIoTwdR = crate :: BitReader ;
#[doc = "Field `SYSINFO_SOC_IO_DMA` reader - Direct memory access controller implemented"] pub type SysinfoSocIoDmaR = crate :: BitReader ;
#[doc = "Field `SYSINFO_SOC_IO_GPIO` reader - General purpose input/output port unit implemented"] pub type SysinfoSocIoGpioR = crate :: BitReader ;
#[doc = "Field `SYSINFO_SOC_IO_CLINT` reader - Core local interruptor implemented"] pub type SysinfoSocIoClintR = crate :: BitReader ;
#[doc = "Field `SYSINFO_SOC_IO_UART0` reader - Primary universal asynchronous receiver/transmitter implemented"] pub type SysinfoSocIoUart0R = crate :: BitReader ;
#[doc = "Field `SYSINFO_SOC_IO_SPI` reader - Serial peripheral interface implemented"] pub type SysinfoSocIoSpiR = crate :: BitReader ;
#[doc = "Field `SYSINFO_SOC_IO_TWI` reader - Two-wire interface implemented"] pub type SysinfoSocIoTwiR = crate :: BitReader ;
#[doc = "Field `SYSINFO_SOC_IO_PWM` reader - Pulse-width modulation unit implemented"] pub type SysinfoSocIoPwmR = crate :: BitReader ;
#[doc = "Field `SYSINFO_SOC_IO_WDT` reader - Watchdog timer implemented"] pub type SysinfoSocIoWdtR = crate :: BitReader ;
#[doc = "Field `SYSINFO_SOC_IO_CFS` reader - Custom functions subsystem implemented"] pub type SysinfoSocIoCfsR = crate :: BitReader ;
#[doc = "Field `SYSINFO_SOC_IO_TRNG` reader - True random number generator implemented"] pub type SysinfoSocIoTrngR = crate :: BitReader ;
#[doc = "Field `SYSINFO_SOC_IO_SDI` reader - Serial data interface implemented"] pub type SysinfoSocIoSdiR = crate :: BitReader ;
#[doc = "Field `SYSINFO_SOC_IO_UART1` reader - Secondary universal asynchronous receiver/transmitter implemented"] pub type SysinfoSocIoUart1R = crate :: BitReader ;
#[doc = "Field `SYSINFO_SOC_IO_NEOLED` reader - NeoPixel-compatible smart LED interface implemented"] pub type SysinfoSocIoNeoledR = crate :: BitReader ;
#[doc = "Field `SYSINFO_SOC_IO_TRACER` reader - Execution tracer implemented"] pub type SysinfoSocIoTracerR = crate :: BitReader ;
#[doc = "Field `SYSINFO_SOC_IO_GPTMR` reader - General purpose timer implemented"] pub type SysinfoSocIoGptmrR = crate :: BitReader ;
#[doc = "Field `SYSINFO_SOC_IO_SLINK` reader - Stream link interface implemented"] pub type SysinfoSocIoSlinkR = crate :: BitReader ;
#[doc = "Field `SYSINFO_SOC_IO_ONEWIRE` reader - 1-wire interface controller implemented"] pub type SysinfoSocIoOnewireR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Bootloader implemented"]
#[inline (always)] pub fn sysinfo_soc_bootloader (& self) -> SysinfoSocBootloaderR { SysinfoSocBootloaderR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - External bus interface implemented"]
#[inline (always)] pub fn sysinfo_soc_xbus (& self) -> SysinfoSocXbusR { SysinfoSocXbusR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Processor-internal instruction memory implemented"]
#[inline (always)] pub fn sysinfo_soc_imem (& self) -> SysinfoSocImemR { SysinfoSocImemR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Processor-internal data memory implemented"]
#[inline (always)] pub fn sysinfo_soc_dmem (& self) -> SysinfoSocDmemR { SysinfoSocDmemR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - On-chip debugger implemented"]
#[inline (always)] pub fn sysinfo_soc_ocd (& self) -> SysinfoSocOcdR { SysinfoSocOcdR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Processor-internal instruction cache implemented"]
#[inline (always)] pub fn sysinfo_soc_icache (& self) -> SysinfoSocIcacheR { SysinfoSocIcacheR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Processor-internal data cache implemented"]
#[inline (always)] pub fn sysinfo_soc_dcache (& self) -> SysinfoSocDcacheR { SysinfoSocDcacheR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 11 - On-chip debugger authentication implemented"]
#[inline (always)] pub fn sysinfo_soc_ocd_auth (& self) -> SysinfoSocOcdAuthR { SysinfoSocOcdAuthR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Processor-internal instruction memory implemented as pre-initialized ROM"]
#[inline (always)] pub fn sysinfo_soc_imem_rom (& self) -> SysinfoSocImemRomR { SysinfoSocImemRomR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Two-wire device implemented"]
#[inline (always)] pub fn sysinfo_soc_io_twd (& self) -> SysinfoSocIoTwdR { SysinfoSocIoTwdR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Direct memory access controller implemented"]
#[inline (always)] pub fn sysinfo_soc_io_dma (& self) -> SysinfoSocIoDmaR { SysinfoSocIoDmaR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - General purpose input/output port unit implemented"]
#[inline (always)] pub fn sysinfo_soc_io_gpio (& self) -> SysinfoSocIoGpioR { SysinfoSocIoGpioR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Core local interruptor implemented"]
#[inline (always)] pub fn sysinfo_soc_io_clint (& self) -> SysinfoSocIoClintR { SysinfoSocIoClintR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Primary universal asynchronous receiver/transmitter implemented"]
#[inline (always)] pub fn sysinfo_soc_io_uart0 (& self) -> SysinfoSocIoUart0R { SysinfoSocIoUart0R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Serial peripheral interface implemented"]
#[inline (always)] pub fn sysinfo_soc_io_spi (& self) -> SysinfoSocIoSpiR { SysinfoSocIoSpiR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Two-wire interface implemented"]
#[inline (always)] pub fn sysinfo_soc_io_twi (& self) -> SysinfoSocIoTwiR { SysinfoSocIoTwiR :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Pulse-width modulation unit implemented"]
#[inline (always)] pub fn sysinfo_soc_io_pwm (& self) -> SysinfoSocIoPwmR { SysinfoSocIoPwmR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Watchdog timer implemented"]
#[inline (always)] pub fn sysinfo_soc_io_wdt (& self) -> SysinfoSocIoWdtR { SysinfoSocIoWdtR :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - Custom functions subsystem implemented"]
#[inline (always)] pub fn sysinfo_soc_io_cfs (& self) -> SysinfoSocIoCfsR { SysinfoSocIoCfsR :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - True random number generator implemented"]
#[inline (always)] pub fn sysinfo_soc_io_trng (& self) -> SysinfoSocIoTrngR { SysinfoSocIoTrngR :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - Serial data interface implemented"]
#[inline (always)] pub fn sysinfo_soc_io_sdi (& self) -> SysinfoSocIoSdiR { SysinfoSocIoSdiR :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Secondary universal asynchronous receiver/transmitter implemented"]
#[inline (always)] pub fn sysinfo_soc_io_uart1 (& self) -> SysinfoSocIoUart1R { SysinfoSocIoUart1R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - NeoPixel-compatible smart LED interface implemented"]
#[inline (always)] pub fn sysinfo_soc_io_neoled (& self) -> SysinfoSocIoNeoledR { SysinfoSocIoNeoledR :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - Execution tracer implemented"]
#[inline (always)] pub fn sysinfo_soc_io_tracer (& self) -> SysinfoSocIoTracerR { SysinfoSocIoTracerR :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - General purpose timer implemented"]
#[inline (always)] pub fn sysinfo_soc_io_gptmr (& self) -> SysinfoSocIoGptmrR { SysinfoSocIoGptmrR :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - Stream link interface implemented"]
#[inline (always)] pub fn sysinfo_soc_io_slink (& self) -> SysinfoSocIoSlinkR { SysinfoSocIoSlinkR :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - 1-wire interface controller implemented"]
#[inline (always)] pub fn sysinfo_soc_io_onewire (& self) -> SysinfoSocIoOnewireR { SysinfoSocIoOnewireR :: new (((self . bits >> 30) & 1) != 0) } }
#[doc = "SoC configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`soc::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SocSpec ; impl crate :: RegisterSpec for SocSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`soc::R`](R) reader structure"] impl crate :: Readable for SocSpec { }
#[doc = "`reset()` method sets SOC to value 0"] impl crate :: Resettable for SocSpec { } }
#[doc = "CACHE (r) register accessor: Cache configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`cache::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cache`] module"]
#[doc (alias = "CACHE")] pub type Cache = crate :: Reg < cache :: CacheSpec > ;
#[doc = "Cache configuration"] pub mod cache {
#[doc = "Register `CACHE` reader"] pub type R = crate :: R < CacheSpec > ;
#[doc = "Field `SYSINFO_CACHE_INST_BLOCK_SIZE` reader - i-cache: log2(Block size in bytes)"] pub type SysinfoCacheInstBlockSizeR = crate :: FieldReader ;
#[doc = "Field `SYSINFO_CACHE_INST_NUM_BLOCKS` reader - i-cache: log2(Number of cache blocks)"] pub type SysinfoCacheInstNumBlocksR = crate :: FieldReader ;
#[doc = "Field `SYSINFO_CACHE_DATA_BLOCK_SIZE` reader - d-cache: log2(Block size in bytes)"] pub type SysinfoCacheDataBlockSizeR = crate :: FieldReader ;
#[doc = "Field `SYSINFO_CACHE_DATA_NUM_BLOCKS` reader - d-cache: log2(Number of cache blocks)"] pub type SysinfoCacheDataNumBlocksR = crate :: FieldReader ;
#[doc = "Field `SYSINFO_CACHE_INST_BURSTS_EN` reader - i-cache: burst transfers enabled"] pub type SysinfoCacheInstBurstsEnR = crate :: BitReader ;
#[doc = "Field `SYSINFO_CACHE_DATA_BURSTS_EN` reader - d-cache: burst transfers enabled"] pub type SysinfoCacheDataBurstsEnR = crate :: BitReader ; impl R {
#[doc = "Bits 0:3 - i-cache: log2(Block size in bytes)"]
#[inline (always)] pub fn sysinfo_cache_inst_block_size (& self) -> SysinfoCacheInstBlockSizeR { SysinfoCacheInstBlockSizeR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:7 - i-cache: log2(Number of cache blocks)"]
#[inline (always)] pub fn sysinfo_cache_inst_num_blocks (& self) -> SysinfoCacheInstNumBlocksR { SysinfoCacheInstNumBlocksR :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:11 - d-cache: log2(Block size in bytes)"]
#[inline (always)] pub fn sysinfo_cache_data_block_size (& self) -> SysinfoCacheDataBlockSizeR { SysinfoCacheDataBlockSizeR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bits 12:15 - d-cache: log2(Number of cache blocks)"]
#[inline (always)] pub fn sysinfo_cache_data_num_blocks (& self) -> SysinfoCacheDataNumBlocksR { SysinfoCacheDataNumBlocksR :: new (((self . bits >> 12) & 0x0f) as u8) }
#[doc = "Bit 16 - i-cache: burst transfers enabled"]
#[inline (always)] pub fn sysinfo_cache_inst_bursts_en (& self) -> SysinfoCacheInstBurstsEnR { SysinfoCacheInstBurstsEnR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 24 - d-cache: burst transfers enabled"]
#[inline (always)] pub fn sysinfo_cache_data_bursts_en (& self) -> SysinfoCacheDataBurstsEnR { SysinfoCacheDataBurstsEnR :: new (((self . bits >> 24) & 1) != 0) } }
#[doc = "Cache configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`cache::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CacheSpec ; impl crate :: RegisterSpec for CacheSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cache::R`](R) reader structure"] impl crate :: Readable for CacheSpec { }
#[doc = "`reset()` method sets CACHE to value 0"] impl crate :: Resettable for CacheSpec { } } }
#[unsafe (no_mangle)] static mut DEVICE_PERIPHERALS : bool = false ;
#[doc = r" All the peripherals."]
#[allow (non_snake_case)] pub struct Peripherals {
#[doc = "CFS"] pub cfs : Cfs ,
#[doc = "SDI"] pub sdi : Sdi ,
#[doc = "SLINK"] pub slink : Slink ,
#[doc = "DMA"] pub dma : Dma ,
#[doc = "PWM"] pub pwm : Pwm ,
#[doc = "GPTMR"] pub gptmr : Gptmr ,
#[doc = "ONEWIRE"] pub onewire : Onewire ,
#[doc = "CLINT"] pub clint : Clint ,
#[doc = "UART0"] pub uart0 : Uart0 ,
#[doc = "UART1"] pub uart1 : Uart1 ,
#[doc = "SPI"] pub spi : Spi ,
#[doc = "TWI"] pub twi : Twi ,
#[doc = "TWD"] pub twd : Twd ,
#[doc = "TRNG"] pub trng : Trng ,
#[doc = "WDT"] pub wdt : Wdt ,
#[doc = "GPIO"] pub gpio : Gpio ,
#[doc = "NEOLED"] pub neoled : Neoled ,
#[doc = "TRACER"] pub tracer : Tracer ,
#[doc = "SYSINFO"] pub sysinfo : Sysinfo , } impl Peripherals {
#[doc = r" Returns all the peripherals *once*."]
#[cfg (feature = "critical-section")]
#[inline] pub fn take () -> Option < Self > { critical_section :: with (| _ | { if unsafe { DEVICE_PERIPHERALS } { return None } Some (unsafe { Peripherals :: steal () }) }) }
#[doc = r" Unchecked version of `Peripherals::take`."]
#[doc = r""]
#[doc = r" # Safety"]
#[doc = r""]
#[doc = r" Each of the returned peripherals must be used at most once."]
#[inline] pub unsafe fn steal () -> Self { DEVICE_PERIPHERALS = true ; Peripherals { cfs : unsafe { Cfs :: steal () } , sdi : unsafe { Sdi :: steal () } , slink : unsafe { Slink :: steal () } , dma : unsafe { Dma :: steal () } , pwm : unsafe { Pwm :: steal () } , gptmr : unsafe { Gptmr :: steal () } , onewire : unsafe { Onewire :: steal () } , clint : unsafe { Clint :: steal () } , uart0 : unsafe { Uart0 :: steal () } , uart1 : unsafe { Uart1 :: steal () } , spi : unsafe { Spi :: steal () } , twi : unsafe { Twi :: steal () } , twd : unsafe { Twd :: steal () } , trng : unsafe { Trng :: steal () } , wdt : unsafe { Wdt :: steal () } , gpio : unsafe { Gpio :: steal () } , neoled : unsafe { Neoled :: steal () } , tracer : unsafe { Tracer :: steal () } , sysinfo : unsafe { Sysinfo :: steal () } , } } }